# draft
## central =====
library(dplyr)
library(data.table)
library(plyr)
library(reshape2)
library(readxl)
options(scipen = 999)

masterfile_raw<- fread("E:/shubhi ahuja/d/Shubhi/15 Unit Economics/6_Dec20/outputs/1revenue/Revenue_Q3FY21_scaled.csv",colClasses = c(customer_code= "character"))
names(masterfile_raw)

# Ivr 
ivr_excel <- fread("E:/shubhi ahuja/d/Shubhi/15 Unit Economics/5_JunSep20/inputs/us/Aditya/ivr_centralQ3.csv",colClasses = c(customer_code="character"))
class(ivr_excel$customer_code)
names(ivr_excel)
ivr_excel <- ivr_excel[,c("customer_code","Sum of IVR")]

masterfile<- left_join(masterfile_raw,ivr_excel,by="customer_code")

#******************************************************************
# Pull SR+ Complaints data customer wise, for the quarter, and append it like the ivr file
# name the total SR+ Complaint Requests as : SR_CR
#***********************************************************************  

# select customer_code, sum(SR_CR) as SR_CR from
# (select customer_code,1 as SR_CR from dl_accounts as A
#   inner join
#   dbo.SF_Tickets as S
#   ON
#   A.account_number = S.account_number
#   where (ticket_no like 'SR%' or ticket_no like 'CR%')
#   and creation_date between '2020-10-01' and '2020-12-31')ss
# group by customer_code

cr_sr <- fread("E:/shubhi ahuja/d/Shubhi/15 Unit Economics/6_Dec20/inputs/3cost/cr_sr.rpt",colClasses = c(customer_code="character"),sep="~")
str(cr_sr)

masterfile<- left_join(masterfile,cr_sr,by="customer_code")

masterfile$cxcodeflag <- 1 # flag to capture count of customers (count of customer_codes)
names(masterfile)
class(masterfile$cif_branch_code) # char ; shud this be changed to factor?
class(masterfile$segment) # char ; advantage of changing to factor? 
class(masterfile$`Sum of IVR`) # 


class(masterfile$time_taken)

#Payments : RTGS ,NEFT ,Cheque,imps
class(masterfile$rtgs_out_branch)
class(masterfile$RTGS_out_mob)
class(masterfile$RTGS_out_ebanking)
class(masterfile$neft_out_mob)
class(masterfile$neft_out_branch)
class(masterfile$neft_out_ebanking)
class(masterfile$chq_inward)
class(masterfile$chq_outward)
class(masterfile$ib_imps_transactions)
class(masterfile$mob_imps)
class(masterfile$rtgs_in)
class(masterfile$neft_in)
# Only 0 values captured
table(masterfile$rtgs_in)
table(masterfile$neft_in)

masterfile$Payments <- masterfile$rtgs_out_branch + masterfile$RTGS_out_mob + masterfile$RTGS_out_ebanking +
  masterfile$neft_out_mob + masterfile$neft_out_branch + masterfile$neft_out_ebanking +
  masterfile$chq_inward + masterfile$chq_outward + masterfile$ib_imps_transactions +
  masterfile$mob_imps + masterfile$rtgs_in + masterfile$neft_in

ph<- fread("E:/shubhi ahuja/d/Shubhi/ph/PH_Customer_file_2020_12_31.csv",colClasses = c(customer_code = "character"))
#ph<- fread("D:/Vinay Achipalya BKP 20 Aug 2019/Work/PH Files/June_2020_Customer_PH.csv",colClasses = c(customer_code = "character"))
dd<- ph[duplicated(ph$customer_code),]; nrow(dd); rm(dd)# no duplicates in ph

names(ph)

ph_needed <- ph[,c("customer_code","cms_mapping","UPH","TPH","Trade_Forex","MF_Flag")]

masterfile <- left_join(masterfile,ph_needed,by="customer_code")


class(masterfile$Trade_Forex)
#setnames(masterfile,old="TFX",new="TFx")


# All should be numeric
class(masterfile$Payments) # 
class(masterfile$SR_CR) # !!!!!!!!!!!!!!!!!
class(masterfile$FinalTFX) # FinalTFX ***** we create this variable later
class(masterfile$Digital_txns)
class(masterfile$cms_mapping)#*******
class(masterfile$no_of_accounts)
masterfile$no_of_accounts <- as.numeric(masterfile$no_of_accounts)

setnames(masterfile, old="time_taken",new="Total_Time_taken")

class(masterfile$Total_Time_taken)  # abacus to be excluded in this
# since account opening team doesn't open abacus accounts
masterfile$Total_Time_taken <- as.numeric(masterfile$Total_Time_taken)

class(masterfile$no_of_accounts) #no_of_accounts is what we had called TotalProducts earlier
class(masterfile$cxcodeflag)

# Adding needed field of average MAB

# Calculating Average MAB for this.
library(lubridate)
head(masterfile$create_date,3)
masterfile$create_date <- ymd(masterfile$create_date)

m1 <- '31-10-2020'
m2<- '30-11-2020'

m1<- as.Date(m1, "%d-%m-%Y")
m2<- as.Date(m2, "%d-%m-%Y")

masterfile$new_vintage <- ifelse(masterfile$create_date <= m1,3,
                                 ifelse(masterfile$create_date<=m2,2,1))

table(masterfile$new_vintage)

masterfile$avgMAB <- (masterfile$avg_deposit_balance_M1_CA+masterfile$avg_deposit_balance_M1_SA+
                        masterfile$avg_deposit_balance_M2_CA+masterfile$avg_deposit_balance_M2_SA+
                        masterfile$avg_deposit_balance_M3_CA+masterfile$avg_deposit_balance_M3_SA)/masterfile$new_vintage

# Adding total txns:
class(masterfile$Digital_txns)

class(masterfile$ATM_withdraw)
class(masterfile$total_branch_txns)
class(masterfile$Digital_txns)
class(masterfile$debit_card_pos_usage_count)
class(masterfile$debit_card_ecom_usage_count)



masterfile$total_txns <- ( masterfile$ATM_withdraw+ masterfile$total_branch_txns +masterfile$Digital_txns+
                             masterfile$debit_card_pos_usage_count+ masterfile$debit_card_ecom_usage_count )

#setnames(masterfile,old="Final Segment", new= "segment")
class(masterfile$avgMAB)
class(masterfile$total_txns)

colSums(is.na(masterfile))
masterfile[is.na(masterfile)] <- 0 # Replacing all NAs with 0

masterfile$FinalTFX <- rowSums(masterfile[,c("Others","TradeIncome")],na.rm = T) # Final Tfx

setnames(masterfile,old="atm_txns",new="ATM txns")
masterfile$`ATM txns` <- as.integer(masterfile$`ATM txns`)

masterfile[is.na(masterfile)] <- 0

# ============ Filter to get BBB details =====================
table(masterfile$zone_name)
BBB<- masterfile %>% filter(!zone_name %in% c('GMNE - Rural Zone','Kolhapur- Rural Zone'))
table(BBB$zone_name)


# === RBU details ====2
RBU <- masterfile %>% filter(zone_name %in% c('GMNE - Rural Zone','Kolhapur- Rural Zone'))
table(RBU$zone_name)

# Keeping fields needed to make pivots
table(BBB$`Sum of IVR`)

class(masterfile$FinalTFX)

# ADD the field : SR_CR*************************************************
BBBsel<- BBB[,c("cif_branch_code","segment","Sum of IVR" ,"Payments","FinalTFX","Digital_txns","cms_mapping",
                "ATM txns","Total_Time_taken","no_of_accounts","cxcodeflag","total_branch_txns",
                "avgMAB","total_txns","MF_Flag","Trade_Forex","SR_CR")]

#BBBsel<- BBB %>% select (cif_branch_code,segment,`Sum of IVR`,Payments,FinalTFX,Digital_txns,cms_mapping,
#                         `ATM txns`,Total_Time_taken,no_of_accounts,cxcodeflag,total_branch_txns,avgMAB,total_txns,MF_Flag,Trade_Forex)

ncol(BBBsel)
str(BBBsel)
BBBagg<- aggregate(BBBsel[,c(3,4,5,6,7,8,9,10,11,12,13,14,15,16,17)], BBBsel[,c(1,2)], FUN = sum, na.rm=T)

#BBBagg <- BBBsel %>% group_by(cif_branch_code,segment) %>% summarize_all(funs(sum))


BBBagg$cif_branch_code <- as.numeric(BBBagg$cif_branch_code)
BBBagg <- BBBagg[order(BBBagg$cif_branch_code),] # ordering by branch code
# aggregate (table[,c(columns to be aggregated)],table[,c(columns to be aggregated on)],fun = aggregation to be done, na.rm)
BBBagg <- BBBagg %>% filter (!cif_branch_code %in% c('990','991','992','993','null','0','999'))

max(BBBagg$cif_branch_code)# should not be 990ish, if yes, remove that branch in line above too


#### =======================BBB =====================================2
## =================================================================2


# Driver Creation ====

############## MF cx DRIver
MF_B<- dcast(BBBagg,cif_branch_code~segment,value.var="MF_Flag")

# After dcast, for missing values, we get NA =
colSums(is.na(MF_B))
MF_B[is.na(MF_B)] = 0

MF_B <- MF_B %>% 
  mutate(BranchLevel= rowSums(MF_B[,c('Abacus','Aspire','Diplomat','Insignia','Mass','NR','Salary','Signature','Tasc')],na.rm=TRUE))

MF_B$Grandtotal = sum(MF_B$BranchLevel)

# Driver value: Proportion of Payments for Segment, Branch divided by Grand Total 
# ======== % value of drivers ======2
MF_Bdr <- MF_B %>% mutate (
  Abacus = (Abacus/Grandtotal),Diplomat= (Diplomat/Grandtotal),Insignia=(Insignia/Grandtotal),
  NR=(NR/Grandtotal),Signature=(Signature/Grandtotal),Salary=(Salary/Grandtotal),
  Tasc=(Tasc/Grandtotal),Mass=(Mass/Grandtotal),Aspire=(Aspire/Grandtotal))

names(MF_Bdr)

# Removing Grand total, and branch total columns, since they are not needed

MF_Bdr<- MF_Bdr[,c("cif_branch_code","Abacus","Diplomat","Insignia","NR","Signature","Salary","Tasc",
                   "Mass","Aspire")]

############## SR+ Complaints
SR_B<- dcast(BBBagg,cif_branch_code~segment,value.var="SR_CR")

# After dcast, for missing values, we get NA =
colSums(is.na(SR_B))
SR_B[is.na(SR_B)] = 0

SR_B <- SR_B %>% 
  mutate(BranchLevel= rowSums(SR_B[,c('Abacus','Aspire','Diplomat','Insignia','Mass','NR','Salary','Signature','Tasc')],na.rm=TRUE))

SR_B$Grandtotal = sum(SR_B$BranchLevel)

# Driver value: Proportion of Payments for Segment, Branch divided by Grand Total 
# ======== % value of drivers ======2
SR_Bdr <- SR_B %>% mutate (
  Abacus = (Abacus/Grandtotal),Diplomat= (Diplomat/Grandtotal),Insignia=(Insignia/Grandtotal),
  NR=(NR/Grandtotal),Signature=(Signature/Grandtotal),Salary=(Salary/Grandtotal),
  Tasc=(Tasc/Grandtotal),Mass=(Mass/Grandtotal),Aspire=(Aspire/Grandtotal))

names(SR_Bdr)

# Removing Grand total, and branch total columns, since they are not needed

SR_Bdr<- SR_Bdr[,c("cif_branch_code","Abacus","Diplomat","Insignia","NR","Signature","Salary","Tasc",
                   "Mass","Aspire")]


#######DRiver for Trade_Forex : Trade forex cx
# Abacus to be removed from this

Trade_Forex_B<- dcast(BBBagg,cif_branch_code~segment,value.var="Trade_Forex")


# After dcast, for missing values, we get NA =
colSums(is.na(Trade_Forex_B))
Trade_Forex_B[is.na(Trade_Forex_B)] = 0

# 'Abacus',removed from this*************************************
Trade_Forex_B <- Trade_Forex_B %>% 
  mutate(BranchLevel= rowSums(Trade_Forex_B[,c('Aspire','Diplomat','Insignia','Mass','NR','Salary','Signature','Tasc')],na.rm=TRUE))

Trade_Forex_B$Grandtotal = sum(Trade_Forex_B$BranchLevel)

# Driver value: Proportion of Payments for Segment, Branch divided by Grand Total 

# ======== % value of drivers ======2
Trade_Forex_Bdr <- Trade_Forex_B %>% mutate (Diplomat= (Diplomat/Grandtotal),Insignia=(Insignia/Grandtotal),
                                             NR=(NR/Grandtotal),Signature=(Signature/Grandtotal),Salary=(Salary/Grandtotal),
                                             Tasc=(Tasc/Grandtotal),Mass=(Mass/Grandtotal),Aspire=(Aspire/Grandtotal))

names(Trade_Forex_Bdr)

# Removing Grand total, and branch total columns, since they are not needed

Trade_Forex_Bdr<- Trade_Forex_Bdr[,c("cif_branch_code","Diplomat","Insignia","NR","Signature","Salary","Tasc",
                                     "Mass","Aspire")]
sum(Trade_Forex_Bdr,na.rm=T)- sum(Trade_Forex_Bdr$cif_branch_code) # should be 1

#####================================= Tfx Revenue
#### ================================== Tfx Revenue

TfxB<- dcast(BBBagg,cif_branch_code~segment,value.var="FinalTFX")

# After dcast, for missing values, we get NA =
colSums(is.na(TfxB))
TfxB[is.na(TfxB)] = 0

# Getting sum at branch level (will help in opex)
TfxB <- TfxB %>% 
  mutate(BranchLevel= rowSums(TfxB[,c('Abacus','Aspire','Diplomat','Insignia','Mass','NR','Salary','Signature','Tasc')],na.rm=TRUE))

TfxB$Grandtotal = sum(TfxB$BranchLevel)

# Driver value: Proportion of Payments for Segment, Branch divided by Grand Total 
# ======== % value of drivers ======2
TfxBdr <- TfxB %>% mutate (
  Abacus = (Abacus/Grandtotal),Diplomat= (Diplomat/Grandtotal),Insignia=(Insignia/Grandtotal),
  NR=(NR/Grandtotal),Signature=(Signature/Grandtotal),Salary=(Salary/Grandtotal),
  Tasc=(Tasc/Grandtotal),Mass=(Mass/Grandtotal),Aspire=(Aspire/Grandtotal))

names(TfxBdr)

# Removing Grand total, and branch total columns, since they are not needed

TfxBdr<- TfxBdr[,c("cif_branch_code","Abacus","Diplomat","Insignia","NR","Signature","Salary","Tasc",
                   "Mass","Aspire")]

#colnames(TfxBdr)<-paste(colnames(TfxBdr),"TFX",sep="_")
colnames(TfxBdr)[1]="cif_branch_code"

class(TfxBdr)
# ==========================CMS mapping

CMSB<- dcast(BBBagg,cif_branch_code~segment,value.var="cms_mapping")


# After dcast, for missing values, we get NA =
colSums(is.na(CMSB))
CMSB[is.na(CMSB)] = 0


# Getting sum at branch level (will help in opex)
CMSB <- CMSB %>% 
  mutate(BranchLevel= rowSums(CMSB[,c('Abacus','Aspire','Diplomat','Insignia','Mass','NR','Salary','Signature','Tasc')],na.rm=TRUE))

CMSB$Grandtotal = sum(CMSB$BranchLevel)


# Driver value: Proportion of Payments for Segment, Branch divided by Grand Total 

# ======== % value of drivers ======2
CMSBdr <- CMSB %>% mutate (
  Abacus = (Abacus/Grandtotal),Diplomat= (Diplomat/Grandtotal),Insignia=(Insignia/Grandtotal),
  NR=(NR/Grandtotal),Signature=(Signature/Grandtotal),Salary=(Salary/Grandtotal),
  Tasc=(Tasc/Grandtotal),Mass=(Mass/Grandtotal),Aspire=(Aspire/Grandtotal))

names(CMSBdr)

# Removing Grand total, and branch total columns, since they are not needed

CMSBdr<- CMSBdr[,c("cif_branch_code","Abacus","Diplomat","Insignia","NR","Signature",
                   "Salary","Tasc","Mass","Aspire")]


#colnames(CMSBdr)<-paste(colnames(CMSBdr),"CMS",sep="_")
colnames(CMSBdr)[1]="cif_branch_code"
sum(CMSBdr,na.rm=T)- sum(CMSBdr$cif_branch_code) # should be 1

#BAAS_Bdr <- CMSBdr # Baas driver is basis CMS from ph ( taken care of while allocation)

## TFX + CMS
class(TfxBdr)
dim(CMSBdr)
class(CMSBdr)

####======= tfxcmsBdr<- (0.75*TfxBdr) + (0.25*CMSBdr)
tfxcmsBdr<-CMSBdr
names(tfxcmsBdr)
tfxcmsBdr<-tfxcmsBdr[,c('cif_branch_code')]
tfxcmsBdr<-data.frame(tfxcmsBdr)
colnames(tfxcmsBdr)[1]="cif_branch_code"

tfxcmsBdr$Abacus<-((0.75*(TfxBdr$Abacus))+ (0.25*(CMSBdr$Abacus)))
tfxcmsBdr$Diplomat<-((0.75*(TfxBdr$Diplomat))+ (0.25*(CMSBdr$Diplomat)))
tfxcmsBdr$Insignia<-((0.75*(TfxBdr$Insignia))+ (0.25*(CMSBdr$Insignia)))
tfxcmsBdr$NR<-((0.75*(TfxBdr$NR))+ (0.25*(CMSBdr$NR)))
tfxcmsBdr$Signature<-((0.75*(TfxBdr$Signature))+ (0.25*(CMSBdr$Signature)))
tfxcmsBdr$Salary<-((0.75*(TfxBdr$Salary))+ (0.25*(CMSBdr$Salary)))
tfxcmsBdr$Tasc<-((0.75*(TfxBdr$Tasc))+ (0.25*(CMSBdr$Tasc)))
tfxcmsBdr$Mass<-((0.75*(TfxBdr$Mass))+ (0.25*(CMSBdr$Mass)))
tfxcmsBdr$Aspire<-((0.75*(TfxBdr$Aspire))+ (0.25*(CMSBdr$Aspire)))

#colnames(tfxcmsBdr)<-paste(colnames(tfxcmsBdr),"TFX_CMS",sep="_")
colnames(tfxcmsBdr)[1]="cif_branch_code"


### No. of customers ============================2
cxB<- dcast(BBBagg,cif_branch_code~segment,value.var="cxcodeflag")
colSums(is.na(cxB))
cxB[is.na(cxB)] = 0

cxB <- cxB %>% 
  mutate(BranchLevel= rowSums(cxB[,c('Abacus','Aspire','Diplomat','Insignia','Mass','NR','Salary','Signature','Tasc')],na.rm=TRUE))

cxB$Grandtotal = sum(cxB$BranchLevel)

# ======== % value of drivers ======2
cxBdr <- cxB %>% mutate (
  Abacus = (Abacus/Grandtotal),Diplomat= (Diplomat/Grandtotal),Insignia=(Insignia/Grandtotal),
  NR=(NR/Grandtotal),Signature=(Signature/Grandtotal),Salary=(Salary/Grandtotal),
  Tasc=(Tasc/Grandtotal),Mass=(Mass/Grandtotal),Aspire=(Aspire/Grandtotal))
names(cxBdr)
cxBdr<- cxBdr[,c("cif_branch_code","Abacus","Diplomat","Insignia","NR","Signature",
                 "Salary","Tasc","Mass","Aspire")]

#colnames(cxBdr)<-paste(colnames(cxBdr),"Customers",sep="_")
colnames(cxBdr)[1]="cif_branch_code"

# ATM Txns ============2
atmB<- dcast(BBBagg,cif_branch_code~segment,value.var="ATM txns")
colSums(is.na(atmB))
atmB[is.na(atmB)] = 0

atmB <- atmB %>% 
  mutate(BranchLevel= rowSums(atmB[,c('Abacus','Aspire','Diplomat','Insignia','Mass','NR','Salary','Signature','Tasc')],na.rm=TRUE))

atmB$Grandtotal = sum(atmB$BranchLevel)

# == % value of drivers ==
atmBdr <- atmB %>% mutate (
  Abacus = (Abacus/Grandtotal),Diplomat= (Diplomat/Grandtotal),Insignia=(Insignia/Grandtotal),
  NR=(NR/Grandtotal),Signature=(Signature/Grandtotal),Salary=(Salary/Grandtotal),
  Tasc=(Tasc/Grandtotal),Mass=(Mass/Grandtotal),Aspire=(Aspire/Grandtotal)
)
names(atmBdr)
atmBdr<- atmBdr[,c("cif_branch_code","Abacus","Diplomat","Insignia","NR","Signature",
                   "Salary","Tasc","Mass","Aspire")]

#colnames(atmBdr)<-paste(colnames(atmBdr),"ATM",sep="_")
colnames(atmBdr)[1]="cif_branch_code"

# ================  50% CX + 50% ATM
# 0.5 cxBdr + 0.5 atmBdr
cxatmBdr<-cxBdr
names(cxatmBdr)
cxatmBdr<-cxatmBdr[,c('cif_branch_code')]
cxatmBdr<-data.frame(cxatmBdr)
colnames(cxatmBdr)[1]="cif_branch_code"

cxatmBdr$Abacus<-((0.5*(cxBdr$Abacus))+ (0.5*(atmBdr$Abacus)))
cxatmBdr$Diplomat<-((0.5*(cxBdr$Diplomat))+ (0.5*(atmBdr$Diplomat)))
cxatmBdr$Insignia<-((0.5*(cxBdr$Insignia))+ (0.5*(atmBdr$Insignia)))
cxatmBdr$NR<-((0.5*(cxBdr$NR))+ (0.5*(atmBdr$NR)))
cxatmBdr$Signature<-((0.5*(cxBdr$Signature))+ (0.5*(atmBdr$Signature)))
cxatmBdr$Salary<-((0.5*(cxBdr$Salary))+ (0.5*(atmBdr$Salary)))
cxatmBdr$Tasc<-((0.5*(cxBdr$Tasc))+ (0.5*(atmBdr$Tasc)))
cxatmBdr$Mass<-((0.5*(cxBdr$Mass))+ (0.5*(atmBdr$Mass)))
cxatmBdr$Aspire<-((0.5*(cxBdr$Aspire))+ (0.5*(atmBdr$Aspire)))

#colnames(cxatmBdr)<-paste(colnames(cxatmBdr),"Cx_ATM",sep="_")
colnames(cxatmBdr)[1]="cif_branch_code"

## ========================================Payments ====2

PaymentsB<- dcast(BBBagg,cif_branch_code~segment,value.var="Payments")


# After dcast, for missing values, we get NA 
colSums(is.na(PaymentsB))
PaymentsB[is.na(PaymentsB)] = 0


# Getting sum at branch level (will help in opex)
PaymentsB <- PaymentsB %>% 
  mutate(BranchLevel= rowSums(PaymentsB[,c('Abacus','Aspire','Diplomat','Insignia','Mass','NR','Salary','Signature','Tasc')],na.rm=TRUE))

PaymentsB$Grandtotal = sum(PaymentsB$BranchLevel)


# Driver value: Proportion of Payments for Segment, Branch divided by Grand Total 

# ====== % value of drivers ======2
PaymentsBdr <- PaymentsB %>% mutate (
  Abacus = (Abacus/Grandtotal),Diplomat= (Diplomat/Grandtotal),Insignia=(Insignia/Grandtotal),
  NR=(NR/Grandtotal),Signature=(Signature/Grandtotal),Salary=(Salary/Grandtotal),
  Tasc=(Tasc/Grandtotal),Mass=(Mass/Grandtotal),Aspire=(Aspire/Grandtotal))

names(PaymentsBdr)

# Removing Grand total, and branch total columns, since they are not needed

PaymentsBdr<- PaymentsBdr[,c("cif_branch_code","Abacus","Diplomat","Insignia","NR","Signature",
                             "Salary","Tasc","Mass","Aspire")]

#colnames(PaymentsBdr)<-paste(colnames(PaymentsBdr),"Payments",sep="_")
colnames(PaymentsBdr)[1]="cif_branch_code"

# Digital ==========================================2

DigB<- dcast(BBBagg,cif_branch_code~segment,value.var="Digital_txns")
colSums(is.na(DigB))
DigB[is.na(DigB)] = 0

DigB <- DigB %>% 
  mutate(BranchLevel= rowSums(DigB[,c('Abacus','Aspire','Diplomat','Insignia','Mass','NR','Salary','Signature','Tasc')],na.rm=TRUE))

DigB$Grandtotal = sum(DigB$BranchLevel)

# == % value of drivers ==
DigBdr <- DigB %>% mutate (
  Abacus = (Abacus/Grandtotal),Diplomat= (Diplomat/Grandtotal),Insignia=(Insignia/Grandtotal),
  NR=(NR/Grandtotal),Signature=(Signature/Grandtotal),Salary=(Salary/Grandtotal),
  Tasc=(Tasc/Grandtotal),Mass=(Mass/Grandtotal),Aspire=(Aspire/Grandtotal))
names(DigBdr)
DigBdr<- DigBdr[,c("cif_branch_code","Abacus","Diplomat","Insignia","NR","Signature",
                   "Salary","Tasc","Mass","Aspire")]

#colnames(DigBdr)<-paste(colnames(DigBdr),"Digital",sep="_")
colnames(DigBdr)[1]="cif_branch_code"

# Branch Txns ==========================================2
BranchB<- dcast(BBBagg,cif_branch_code~segment,value.var="total_branch_txns")
colSums(is.na(BranchB))
BranchB[is.na(BranchB)] = 0

BranchB <- BranchB %>% 
  mutate(BranchLevel= rowSums(BranchB[,c('Abacus','Aspire','Diplomat','Insignia','Mass','NR','Salary','Signature','Tasc')],na.rm=TRUE))

BranchB$Grandtotal = sum(BranchB$BranchLevel)

# == % value of drivers ==
BranchBdr <- BranchB %>% mutate (
  Abacus = (Abacus/Grandtotal),Diplomat= (Diplomat/Grandtotal),Insignia=(Insignia/Grandtotal),
  NR=(NR/Grandtotal),Signature=(Signature/Grandtotal),Salary=(Salary/Grandtotal),
  Tasc=(Tasc/Grandtotal),Mass=(Mass/Grandtotal),Aspire=(Aspire/Grandtotal)
)
names(BranchBdr)
BranchBdr<- BranchBdr[,c("cif_branch_code","Abacus","Diplomat","Insignia","NR","Signature",
                         "Salary","Tasc","Mass","Aspire")]

#colnames(BranchBdr)<-paste(colnames(BranchBdr),"Branch",sep="_")
colnames(BranchBdr)[1]="cif_branch_code"

### 20% Branch + 80% Digital  =============================2
# .2 * BranchBdr + 0.8 * DigBdr

br_dig_B <- BranchBdr
names(br_dig_B)
br_dig_B<-br_dig_B[,c('cif_branch_code')]
br_dig_B<-data.frame(br_dig_B)
colnames(br_dig_B)[1]="cif_branch_code"

br_dig_B$Abacus<-((0.2*(BranchBdr$Abacus))+ (0.8*(DigBdr$Abacus)))
br_dig_B$Diplomat<-((0.2*(BranchBdr$Diplomat))+ (0.8*(DigBdr$Diplomat)))
br_dig_B$Insignia<-((0.2*(BranchBdr$Insignia))+ (0.8*(DigBdr$Insignia)))
br_dig_B$NR<-((0.2*(BranchBdr$NR))+ (0.8*(DigBdr$NR)))
br_dig_B$Signature<-((0.2*(BranchBdr$Signature))+ (0.8*(DigBdr$Signature)))
br_dig_B$Salary<-((0.2*(BranchBdr$Salary))+ (0.8*(DigBdr$Salary)))
br_dig_B$Tasc<-((0.2*(BranchBdr$Tasc))+ (0.8*(DigBdr$Tasc)))
br_dig_B$Mass<-((0.2*(BranchBdr$Mass))+ (0.8*(DigBdr$Mass)))  
br_dig_B$Aspire<-((0.2*(BranchBdr$Aspire))+ (0.8*(DigBdr$Aspire)))

#colnames(br_dig_B)<-paste(colnames(br_dig_B),"Branch_dig",sep="_")
colnames(br_dig_B)[1]="cif_branch_code"

# Accounts opened ========================================2

AccB<- dcast(BBBagg,cif_branch_code~segment,value.var="no_of_accounts")
colSums(is.na(AccB))
AccB[is.na(AccB)] = 0

AccB <- AccB %>% 
  mutate(BranchLevel= rowSums(AccB[,c('Abacus','Aspire','Diplomat','Insignia','Mass','NR','Salary','Signature','Tasc')],na.rm=TRUE))

AccB$Grandtotal = sum(AccB$BranchLevel)

# == % value of drivers ==
AccBdr <- AccB %>% mutate (
  Abacus = (Abacus/Grandtotal),Diplomat= (Diplomat/Grandtotal),Insignia=(Insignia/Grandtotal),
  NR=(NR/Grandtotal),Signature=(Signature/Grandtotal),Salary=(Salary/Grandtotal),
  Tasc=(Tasc/Grandtotal),Mass=(Mass/Grandtotal),Aspire=(Aspire/Grandtotal))
names(AccBdr)
AccBdr<- AccBdr[,c("cif_branch_code","Abacus","Diplomat","Insignia","NR","Signature",
                   "Salary","Tasc","Mass","Aspire")]

#colnames(AccBdr)<-paste(colnames(AccBdr),"Acc_Opened",sep="_")
colnames(AccBdr)[1]="cif_branch_code"

#### BSG driver ================================================2
# 25% accounts opened + 75% Branch_digital (20% Branch + 80% Digital )
#  (0.75*br_dig_B)+ (0.25*AccBdr)

BSGBdr<-br_dig_B
names(BSGBdr)
BSGBdr<-BSGBdr[,c('cif_branch_code')]
BSGBdr<-data.frame(BSGBdr)
colnames(BSGBdr)[1]="cif_branch_code"

BSGBdr$Abacus<-((0.75*(br_dig_B$Abacus))+ (0.25*(AccBdr$Abacus)))
BSGBdr$Diplomat<-((0.75*(br_dig_B$Diplomat))+ (0.25*(AccBdr$Diplomat)))
BSGBdr$Insignia<-((0.75*(br_dig_B$Insignia))+ (0.25*(AccBdr$Insignia)))
BSGBdr$NR<-((0.75*(br_dig_B$NR))+ (0.25*(AccBdr$NR)))
BSGBdr$Signature<-((0.75*(br_dig_B$Signature))+ (0.25*(AccBdr$Signature)))
BSGBdr$Salary<-((0.75*(br_dig_B$Salary))+ (0.25*(AccBdr$Salary)))
BSGBdr$Tasc<-((0.75*(br_dig_B$Tasc))+ (0.25*(AccBdr$Tasc)))
BSGBdr$Mass<-((0.75*(br_dig_B$Mass))+ (0.25*(AccBdr$Mass)))
BSGBdr$Aspire<-((0.75*(br_dig_B$Aspire))+ (0.25*(AccBdr$Aspire)))


#colnames(BSGBdr)<-paste(colnames(BSGBdr),"BSG",sep="_")
colnames(BSGBdr)[1]="cif_branch_code"

# Time taken for account opening ===================---- 2
# Abacus has to be excluded from this, since account opening team (central) doesn't open abacus accounts

timeaccB<- dcast(BBBagg,cif_branch_code~segment,value.var="Total_Time_taken")
colSums(is.na(timeaccB))
timeaccB[is.na(timeaccB)] = 0

# ***** Excluding ABACUS *****
# Though it appears in table currently, it's value is NOT used in calculating branch level sum
timeaccB <- timeaccB %>% 
  mutate(BranchLevel= rowSums(timeaccB[,c('Aspire','Diplomat','Insignia','Mass','NR','Salary','Signature','Tasc')],na.rm=TRUE))

timeaccB$Grandtotal = sum(timeaccB$BranchLevel)

# == % value of drivers ==
# Removed abacus here too
timeaccBdr <- timeaccB %>% mutate ( #Abacus = (Abacus/Grandtotal)*100,
  Diplomat= (Diplomat/Grandtotal),Insignia=(Insignia/Grandtotal),
  NR=(NR/Grandtotal),Signature=(Signature/Grandtotal),Salary=(Salary/Grandtotal),
  Tasc=(Tasc/Grandtotal),Mass=(Mass/Grandtotal),Aspire=(Aspire/Grandtotal)
)
names(timeaccBdr)
timeaccBdr<- timeaccBdr[,c("cif_branch_code","Diplomat","Insignia","NR","Signature",
                           "Salary","Tasc","Mass","Aspire")] # removed "Abacus"

#colnames(timeaccBdr)<-paste(colnames(timeaccBdr),"Time_Acc",sep="_")
colnames(timeaccBdr)[1]="cif_branch_code"
sum(timeaccBdr,na.rm = T)- sum(timeaccBdr$cif_branch_code)
### IVR =====================================================

ivrB<- dcast(BBBagg,cif_branch_code~segment,value.var="Sum of IVR")
colSums(is.na(ivrB))
ivrB[is.na(ivrB)] = 0

ivrB <- ivrB %>% 
  mutate(BranchLevel= rowSums(ivrB[,c('Abacus','Aspire','Diplomat','Insignia','Mass','NR','Salary','Signature','Tasc')],na.rm=TRUE))

ivrB$Grandtotal = sum(ivrB$BranchLevel)

# == % value of drivers ==
ivrBdr <- ivrB %>% mutate (
  Abacus = (Abacus/Grandtotal),Diplomat= (Diplomat/Grandtotal),Insignia=(Insignia/Grandtotal),
  NR=(NR/Grandtotal),Signature=(Signature/Grandtotal),Salary=(Salary/Grandtotal),
  Tasc=(Tasc/Grandtotal),Mass=(Mass/Grandtotal),Aspire=(Aspire/Grandtotal)
)
names(ivrBdr)
ivrBdr<- ivrBdr[,c("cif_branch_code","Abacus","Diplomat","Insignia","NR","Signature",
                   "Salary","Tasc","Mass","Aspire")]


#colnames(ivrBdr)<-paste(colnames(ivrBdr),"Ivr",sep="_")
colnames(ivrBdr)[1]="cif_branch_code"


# Reading people cost file, for HR Driver====
#people_cost <- fread("E:/shubhi ahuja/d/Shubhi/15 Unit Economics/5_JunSep20/output/Sep20/cost/Salary_cost_cx.csv")
people_cost <- fread("E:/shubhi ahuja/d/Shubhi/15 Unit Economics/6_Dec20/outputs/2cost/Q3FY21_ppl_cost_ForCentralCost_part1.csv")

bbb_branches <- unique(BBBagg$cif_branch_code)


hrB<- people_cost %>% filter(cif_branch_code %in% bbb_branches)

class(hrB$Abacus)

#hrBdr

colSums(is.na(hrB))
hrB[is.na(hrB)] = 0
# 'Abacus' removed from this*****************************
hrB <- hrB %>% 
  mutate(BranchLevel= rowSums(hrB[,c('Aspire','Diplomat','Insignia','Mass','NR','Salary','Signature','Tasc')],na.rm=TRUE))

hrB$Grandtotal = sum(hrB$BranchLevel)

# == % value of drivers ==
hrBdr <- hrB %>% mutate (Diplomat= (Diplomat/Grandtotal),Insignia=(Insignia/Grandtotal),
                         NR=(NR/Grandtotal),Signature=(Signature/Grandtotal),Salary=(Salary/Grandtotal),
                         Tasc=(Tasc/Grandtotal),Mass=(Mass/Grandtotal),Aspire=(Aspire/Grandtotal))
names(hrBdr)
hrBdr<- hrBdr[,c("cif_branch_code","Diplomat","Insignia","NR","Signature",
                 "Salary","Tasc","Mass","Aspire")]


sum(hrBdr,na.rm=T)- sum(hrBdr$cif_branch_code) # should be 1

#colnames(ivrBdr)<-paste(colnames(ivrBdr),"Ivr",sep="_")
colnames(hrBdr)[1]="cif_branch_code"

#============= MAB ==============================

MAB_B<- dcast(BBBagg,cif_branch_code~segment,value.var="avgMAB")
names(MAB_B)

# After dcast, for missing values, we get NA, hence, making NA=0, for smoothening further calculation
colSums(is.na(MAB_B))
MAB_B[is.na(MAB_B)] = 0


# Getting sum at branch level (will help in opex)
MAB_B <- MAB_B %>% 
  mutate(BranchLevel= rowSums(MAB_B[,c('Abacus','Aspire','Diplomat','Insignia','Mass','NR','Salary','Signature','Tasc')],na.rm=TRUE))

MAB_B$Grandtotal = sum(MAB_B$BranchLevel)


# Driver value: Proportion of Payments for Segment, Branch divided by Grand Total 

# ======== % value of drivers ======2
MAB_Bdr <- MAB_B %>% mutate (Abacus = (Abacus/Grandtotal),Diplomat= (Diplomat/Grandtotal),Insignia=(Insignia/Grandtotal),
                             NR=(NR/Grandtotal),Signature=(Signature/Grandtotal),Salary=(Salary/Grandtotal),
                             Tasc=(Tasc/Grandtotal),Mass=(Mass/Grandtotal),Aspire=(Aspire/Grandtotal))

names(MAB_Bdr)

# Removing Grand total, and branch total columns, since they are not needed

MAB_Bdr<- MAB_Bdr[,c("cif_branch_code","Abacus","Diplomat","Insignia","NR","Signature","Salary","Tasc",
                     "Mass","Aspire")]

colnames(MAB_Bdr)<-paste(colnames(MAB_Bdr),"MAB",sep="_")


# ======== Txns

Txns_B<- dcast(BBBagg,cif_branch_code~segment,value.var="total_txns")


# After dcast, for missing values, we get NA =
colSums(is.na(Txns_B))
Txns_B[is.na(Txns_B)] = 0


# Getting sum at branch level (will help in opex)
Txns_B <- Txns_B %>% 
  mutate(BranchLevel= rowSums(Txns_B[,c('Abacus','Aspire','Diplomat','Insignia','Mass','NR','Salary','Signature','Tasc')],na.rm=TRUE))

Txns_B$Grandtotal = sum(Txns_B$BranchLevel)


# Driver value: Proportion of Payments for Segment, Branch divided by Grand Total 

# ======== % value of drivers ======2
Txns_Bdr <- Txns_B %>% mutate (
  Abacus = (Abacus/Grandtotal),Diplomat= (Diplomat/Grandtotal),Insignia=(Insignia/Grandtotal),
  NR=(NR/Grandtotal),Signature=(Signature/Grandtotal),Salary=(Salary/Grandtotal),
  Tasc=(Tasc/Grandtotal),Mass=(Mass/Grandtotal),Aspire=(Aspire/Grandtotal))

names(Txns_Bdr)

# Removing Grand total, and branch total columns, since they are not needed

Txns_Bdr<- Txns_Bdr[,c("cif_branch_code","Abacus","Diplomat","Insignia","NR","Signature","Salary","Tasc",
                       "Mass","Aspire")]

colnames(Txns_Bdr)<-paste(colnames(Txns_Bdr),"Txns",sep="_")



# ================  50% MAB + 50% Txn
# 0.5 MAB + 0.5 Txn
MAB_txn_Bdr<-Txns_Bdr
names(MAB_txn_Bdr)
colnames(MAB_txn_Bdr)[1]="cif_branch_code"
MAB_txn_Bdr<-MAB_txn_Bdr[,c('cif_branch_code')]
MAB_txn_Bdr<-data.frame(MAB_txn_Bdr)
colnames(MAB_txn_Bdr)[1]="cif_branch_code"

MAB_txn_Bdr$Abacus<-((0.5*(MAB_Bdr$Abacus))+ (0.5*(Txns_Bdr$Abacus)))
MAB_txn_Bdr$Diplomat<-((0.5*(MAB_Bdr$Diplomat))+ (0.5*(Txns_Bdr$Diplomat)))
MAB_txn_Bdr$Insignia<-((0.5*(MAB_Bdr$Insignia))+ (0.5*(Txns_Bdr$Insignia)))
MAB_txn_Bdr$NR<-((0.5*(MAB_Bdr$NR))+ (0.5*(Txns_Bdr$NR)))
MAB_txn_Bdr$Signature<-((0.5*(MAB_Bdr$Signature))+ (0.5*(Txns_Bdr$Signature)))
MAB_txn_Bdr$Salary<-((0.5*(MAB_Bdr$Salary))+ (0.5*(Txns_Bdr$Salary)))
MAB_txn_Bdr$Tasc<-((0.5*(MAB_Bdr$Tasc))+ (0.5*(Txns_Bdr$Tasc)))
MAB_txn_Bdr$Mass<-((0.5*(MAB_Bdr$Mass))+ (0.5*(Txns_Bdr$Mass)))
MAB_txn_Bdr$Aspire<-((0.5*(MAB_Bdr$Aspire))+ (0.5*(Txns_Bdr$Aspire)))


#colnames(MAB_txn_Bdr)<-paste(colnames(MAB_txn_Bdr),"MAB_Txns",sep="_")
colnames(MAB_txn_Bdr)[1]="cif_branch_code"

sum(MAB_txn_Bdr,na.rm = T)- sum(MAB_txn_Bdr$cif_branch_code) ####should add up to 1


# ================  50% MAB + 50% Branch Txn
# 0.5 MAB + 0.5 Txn
MAB_Brtxn_Bdr<-MAB_Bdr
names(MAB_Brtxn_Bdr)
colnames(MAB_Brtxn_Bdr)[1]="cif_branch_code"
MAB_Brtxn_Bdr<-MAB_Brtxn_Bdr[,c('cif_branch_code')]
MAB_Brtxn_Bdr<-data.frame(MAB_Brtxn_Bdr)
colnames(MAB_Brtxn_Bdr)[1]="cif_branch_code"

MAB_Brtxn_Bdr$Abacus<-((0.5*(MAB_Bdr$Abacus))+ (0.5*(BranchBdr$Abacus)))
MAB_Brtxn_Bdr$Diplomat<-((0.5*(MAB_Bdr$Diplomat))+ (0.5*(BranchBdr$Diplomat)))
MAB_Brtxn_Bdr$Insignia<-((0.5*(MAB_Bdr$Insignia))+ (0.5*(BranchBdr$Insignia)))
MAB_Brtxn_Bdr$NR<-((0.5*(MAB_Bdr$NR))+ (0.5*(BranchBdr$NR)))
MAB_Brtxn_Bdr$Signature<-((0.5*(MAB_Bdr$Signature))+ (0.5*(BranchBdr$Signature)))
MAB_Brtxn_Bdr$Salary<-((0.5*(MAB_Bdr$Salary))+ (0.5*(BranchBdr$Salary)))
MAB_Brtxn_Bdr$Tasc<-((0.5*(MAB_Bdr$Tasc))+ (0.5*(BranchBdr$Tasc)))
MAB_Brtxn_Bdr$Mass<-((0.5*(MAB_Bdr$Mass))+ (0.5*(BranchBdr$Mass)))
MAB_Brtxn_Bdr$Aspire<-((0.5*(MAB_Bdr$Aspire))+ (0.5*(BranchBdr$Aspire)))


#colnames(MAB_txn_Bdr)<-paste(colnames(MAB_txn_Bdr),"MAB_Txns",sep="_")
colnames(MAB_Brtxn_Bdr)[1]="cif_branch_code"

sum(MAB_Brtxn_Bdr,na.rm = T)- sum(MAB_Brtxn_Bdr$cif_branch_code) ####should add up to 1

###### BBB Allocation ####
cost_raw<-read_excel("E:/shubhi ahuja/d/Shubhi/15 Unit Economics/6_Dec20/Oct'20 to Dec'20_Unit Economics from Grishma/9. December_2020 Cost/Rev Cost files_29012021/1301 Allocated Cost use.xlsx",sheet="use")

library(dplyr)
library(data.table)
library(reshape2)
options(scipen = 999)

drivers_raw <- read_excel("E:/shubhi ahuja/d/Shubhi/15 Unit Economics/5_JunSep20/inputs/us/Allocated_cost_driver.xlsx",sheet="Drivers")

drivers<-left_join(cost_raw,drivers_raw, by ="Business Segment")

chk <- drivers[duplicated(drivers$`Business Segment`),]
chk <- drivers %>% filter(is.na(Driver))
sum(chk$Quarter,na.rm=T)
chk2 <- chk %>% filter(!is.na(Quarter))
chk2 <- chk %>% filter (Quarter != 0)


names(drivers)
setnames(drivers,old="Quarter",new="quarter") #### change it to Quarter2 for Sep file*************
table(drivers$Driver)
# setnames(drivers,old= "Apr-June", new= "Apr_Q")
# setnames(drivers,old= "Jul-Sep", new= "Sep_Q")
unique(drivers$Driver)
class(drivers$quarter)

table(drivers$Driver)

# CMS ***********
cost <- drivers %>% filter(Driver == "cms") %>% 
  summarize(quarter= sum(quarter,na.rm=T)) #%>% group_by(Driver) 
cost<- cost*100000  # values in Lakh in the central allocated file
cost<- as.numeric(cost) # it is stored as df otherwise, and multiplication is not direct

call_df <- CMSBdr  # calling the correct driver

df_sel <- call_df[-1]
df_cif <- call_df[1]

df_all <- df_sel * cost
df_all<- cbind(df_cif,df_all)

CMSBdr_all <- df_all

(sum(CMSBdr_all,na.rm=T)- sum(CMSBdr_all$cif_branch_code))- cost # should be 0 

# TFx txns/ rev

cost <- drivers %>% filter(Driver %in% c("Number of trade & forex txns")) %>% 
  summarize(quarter= sum(quarter)) 
cost<- cost*100000
cost<- as.numeric(cost) # it is stored as df otherwise, and multiplication is not direct

call_df <- TfxBdr  # calling the correct driver

df_sel <- call_df[-1]
df_cif <- call_df[1]

df_all <- df_sel * cost
df_all<- cbind(df_cif,df_all)

TfxBdr_all <- df_all

(sum(TfxBdr_all,na.rm=T)- sum(TfxBdr_all$cif_branch_code))- cost # should be 0 

# ,"Number of forex customers" *******
cost <- drivers %>% filter(Driver %in% c("Number of forex customers")) %>% 
  summarize(quarter= sum(quarter)) 
cost<- cost*100000
cost<- as.numeric(cost) # it is stored as df otherwise, and multiplication is not direct

call_df <- Trade_Forex_Bdr  # calling the correct driver

df_sel <- call_df[-1]
df_cif <- call_df[1]

df_all <- df_sel * cost
df_all<- cbind(df_cif,df_all)

Trade_Forex_Bdr_all <- df_all
Trade_Forex_Bdr_all$Abacus <- 0 # not allocated to Abacus, creating a df for consistency

Trade_Forex_Bdr_all <- Trade_Forex_Bdr_all %>% select(cif_branch_code,Abacus,Diplomat,Insignia,
                                                      NR,Signature,Salary,Tasc,Mass,Aspire)

(sum(Trade_Forex_Bdr_all,na.rm=T)- sum(Trade_Forex_Bdr_all$cif_branch_code))- cost # should be 0 

# "Branch -50% customers +50% atm txns\r\nsimilar for segments" 
cost <- drivers %>% filter(Driver == "Branch -50% customers +50% atm txns\r\nsimilar for segments" ) %>% 
  summarize(quarter) #%>% group_by(Driver) 
# cost <- drivers %>% filter(Driver == "Branch -50% customers +50% atm txns\r\r\nsimilar for segments" ) %>% 
#   summarize(quarter) #%>% group_by(Driver) 
# cost <- drivers %>% filter(Driver == "Branch -50% customers +50% atm txns\r\nsimilar for segments" ) %>% 
#   summarize(quarter) #%>% group_by(Driver) 

cost<- cost *100000 #*0.2 ; not from this time!!, we will take 100% cost now
cost<- as.numeric(cost) # it is stored as df otherwise, and multiplication is not direct

call_df <- cxatmBdr  # calling the correct driver

df_sel <- call_df[-1]
df_cif <- call_df[1]

df_all <- df_sel * cost
df_all<- cbind(df_cif,df_all)

cxatmBdr_all <- df_all

(sum(cxatmBdr_all,na.rm=T)- sum(cxatmBdr_all$cif_branch_code))- cost # should be 0 

# "Number of trade & forex txns &CMS"
cost <- drivers %>% filter(Driver == "Number of trade & forex txns &CMS") %>% 
  summarize(quarter) #%>% group_by(Driver) 
cost<- cost*100000
cost<- as.numeric(cost) # it is stored as df otherwise, and multiplication is not direct
cost

call_df <- tfxcmsBdr  # calling the correct driver

df_sel <- call_df[-1]
df_cif <- call_df[1]

df_all <- df_sel * cost
df_all<- cbind(df_cif,df_all)

tfxcmsBdr_all <- df_all

(sum(tfxcmsBdr_all,na.rm=T)- sum(tfxcmsBdr_all$cif_branch_code))- cost # should be 0 

# "RTGS ,NEFT ,Cheque,imps"

cost <- drivers %>% filter(Driver == "RTGS ,NEFT ,Cheque,imps") %>% 
  summarize(quarter) #%>% group_by(Driver) 
cost<- cost*100000
cost<- as.numeric(cost) # it is stored as df otherwise, and multiplication is not direct
cost

call_df <- PaymentsBdr  # calling the correct driver


df_sel <- call_df[-1]
df_cif <- call_df[1]

df_all <- df_sel * cost
df_all<- cbind(df_cif,df_all)

PaymentsBdr_all <- df_all

(sum(PaymentsBdr_all,na.rm=T)- sum(PaymentsBdr_all$cif_branch_code))- cost # should be 0 

#### BSG *** with Abacus
# "25% accounts opened and 75%txns (20% branch, 40% ebanking nd 40% mobank)"
cost <- drivers %>% filter(Driver == "25% accounts opened and 75%txns (20% branch, 40% ebanking nd 40% mobank)") %>% 
  summarize(quarter) #%>% group_by(Driver) 
cost<- cost*100000
cost<- as.numeric(cost) # it is stored as df otherwise, and multiplication is not direct
cost

call_df <- BSGBdr  # calling the correct driver

df_sel <- call_df[-1]
df_cif <- call_df[1]

df_all <- df_sel * cost
df_all<- cbind(df_cif,df_all)

BSGBdr_all <- df_all

(sum(BSGBdr_all,na.rm=T)- sum(BSGBdr_all$cif_branch_code))- cost # should be 0 

# BSG: seeing value for Abacus using: 75%txns (20% branch, 40% ebanking nd 40% mobank)"
cost <- drivers %>% filter(Driver == "25% accounts opened and 75%txns (20% branch, 40% ebanking nd 40% mobank)") %>% 
  summarize(quarter) #%>% group_by(Driver) 
cost<- cost*100000
cost<- as.numeric(cost) # it is stored as df otherwise, and multiplication is not direct
cost

call_df <- br_dig_B  # calling the correct driver (wo acct opened)

df_sel <- call_df[-1]
df_cif <- call_df[1]

df_all <- df_sel * cost
df_all<- cbind(df_cif,df_all)

br_dig_B_all <- df_all

(sum(br_dig_B_all,na.rm=T)- sum(br_dig_B_all$cif_branch_code))- cost # should be 0 

### Final BSG value will be: Abacus value using br_dig_B_all 
# & excess for Abacus (BSGBdr_all- br_dig_B_all) to be given to Mass

FinalBSG_Bdr_all <- BSGBdr_all
FinalBSG_Bdr_all$Abacus <- br_dig_B_all$Abacus
FinalBSG_Bdr_all$AddToMass <-BSGBdr_all$Abacus - br_dig_B_all$Abacus 
FinalBSG_Bdr_all$MassNew <- FinalBSG_Bdr_all$Mass + FinalBSG_Bdr_all$AddToMass
FinalBSG_Bdr_all$Mass <- FinalBSG_Bdr_all$MassNew
FinalBSG_Bdr_all$MassNew<- NULL; FinalBSG_Bdr_all$AddToMass<- NULL

(sum(FinalBSG_Bdr_all,na.rm=T)- sum(FinalBSG_Bdr_all$cif_branch_code))- cost # should be 0 

# "Number of accounts opened * Minutes to open the account"
# i.e., time taken to open accounts

cost <- drivers %>% filter(Driver == "Number of accounts opened * Minutes to open the account") %>% 
  summarize(quarter= sum(quarter)) #%>% group_by(Driver) 
cost<- cost*100000
cost<- as.numeric(cost) # it is stored as df otherwise, and multiplication is not direct
cost

call_df <- timeaccBdr  # calling the correct driver
ncol(timeaccBdr)# should be 9, no abacus

df_sel <- call_df[-1]
df_cif <- call_df[1]

df_all <- df_sel * cost
df_all<- cbind(df_cif,df_all)

timeaccBdr_all <- df_all
timeaccBdr_all$Abacus <- 0  # Abacus is not to get cost for this driver, for column uniformity, adding abacus

timeaccBdr_all<- timeaccBdr_all[,c("cif_branch_code","Abacus","Diplomat","Insignia","NR","Signature",
                                   "Salary","Tasc","Mass","Aspire")]

(sum(timeaccBdr_all,na.rm=T)- sum(timeaccBdr_all$cif_branch_code))- cost # should be 0 

# Contact centre

cost <- drivers %>% filter(Driver == "IVR") %>% group_by(Driver) %>%  summarize(cost = sum(quarter,na.rm=T)) #%>% group_by(Driver) 
cost<- cost*100000
cost<- as.numeric(cost) # it is stored as df otherwise, and multiplication is not direct
cost

call_df <- ivrBdr  # calling the correct driver


df_sel <- call_df[-1]
df_cif <- call_df[1]

df_all <- df_sel * cost
df_all<- cbind(df_cif,df_all)

ivrBdr_all <- df_all

(sum(ivrBdr_all,na.rm=T)- sum(ivrBdr_all$cif_branch_code))- cost # should be 0 

# HR 
cost <- drivers %>% filter(Driver == "PeopleCost") %>% 
  summarize(quarter) #%>% group_by(Driver) 
cost<- cost*100000
cost<- as.numeric(cost) # it is stored as df otherwise, and multiplication is not direct
cost

call_df <- hrBdr  # calling the correct driver


df_sel <- call_df[-1]
df_cif <- call_df[1]

df_all <- df_sel * cost
df_all<- cbind(df_cif,df_all)

hrBdr_all <- df_all

hrBdr_all$Abacus <- 0 # not allocated to Abacus, creating a df for consistency

hrBdr_all <- hrBdr_all %>% select(cif_branch_code,Abacus,Diplomat,Insignia,
                                  NR,Signature,Salary,Tasc,Mass,Aspire)

(sum(hrBdr_all,na.rm=T)- sum(hrBdr_all$cif_branch_code))- cost # should be 0 

# SR
cost <- drivers %>% filter(Driver == "SR ( service requests) + Complaints") %>% 
  summarize(quarter= sum(quarter,na.rm = T)) #%>% group_by(Driver) 
cost<- cost*100000
cost<- as.numeric(cost) # it is stored as df otherwise, and multiplication is not direct
cost

call_df <- SR_Bdr # calling the correct driver

df_sel <- call_df[-1]
df_cif <- call_df[1]

df_all <- df_sel * cost
df_all<- cbind(df_cif,df_all)

SR_Bdr_all <- df_all
ncol(SR_Bdr_all) # should be 10, with all 9 segments, if some segment is missing, check, use below code for consistency

names(SR_Bdr_all)
## segment chk####
sum(SR_Bdr_all$Abacus,na.rm=T) # if it has a value, DO NOT run the code below
# If abacus/ some other segment is missing, run the below code 

#SR_Bdr_all$Abacus <- 0 # not allocated to Abacus, creating a df for consistency
#SR_Bdr_all <- SR_Bdr_all %>% select(cif_branch_code,Abacus,Diplomat,Insignia,
#                                    NR,Signature,Salary,Tasc,Mass,Aspire)

(sum(SR_Bdr_all,na.rm=T)- sum(SR_Bdr_all$cif_branch_code))- cost # should be 0 

# MF
cost <- drivers %>% filter(Driver == "MF cx") %>% 
  summarize(quarter= sum(quarter,na.rm = T)) #%>% group_by(Driver) 
cost<- cost*100000
cost<- as.numeric(cost) # it is stored as df otherwise, and multiplication is not direct
cost

call_df <- MF_Bdr  # calling the correct driver


df_sel <- call_df[-1]
df_cif <- call_df[1]

df_all <- df_sel * cost
df_all<- cbind(df_cif,df_all)

MF_Bdr_all <- df_all

(sum(MF_Bdr_all,na.rm=T)- sum(MF_Bdr_all$cif_branch_code))- cost # should be 0 


# 50%MAB + 50% txn
cost <- drivers %>% filter(Driver == "MAB+ Txn") %>% 
  group_by(Driver) %>% summarize(quarter= sum(quarter,na.rm = T)) #
cost<- cost*100000
cost<- as.numeric(cost) # it is stored as df otherwise, and multiplication is not direct
cost

call_df <- MAB_txn_Bdr  # calling the correct driver

df_sel <- call_df[-1]
df_cif <- call_df[1]

df_all <- df_sel * cost
df_all<- cbind(df_cif,df_all)

MAB_txn_Bdr_all <- df_all

(sum(MAB_txn_Bdr_all,na.rm=T)- sum(MAB_txn_Bdr_all$cif_branch_code))- cost # should be 0 

## Branch ops + Branch premises
# 50%MAB + 50% Branch txn
cost <- drivers %>% filter(Driver == "MAB+ Txn (Abacus MAB+BranchTxn)") %>% 
  group_by(Driver) %>% summarize(quarter= sum(quarter,na.rm = T)) #
cost<- cost*100000
cost<- as.numeric(cost) # it is stored as df otherwise, and multiplication is not direct
cost

call_df <- MAB_txn_Bdr  # calling the correct driver ( MAB+ txns)

df_sel <- call_df[-1]
df_cif <- call_df[1]

df_all <- df_sel * cost
df_all<- cbind(df_cif,df_all)

MAB_txn_Bdr_all_int <- df_all

(sum(MAB_txn_Bdr_all_int,na.rm=T)- sum(MAB_txn_Bdr_all_int$cif_branch_code))- cost # should be 0 

# 50%MAB + 50% Branch txn : Abacus
cost <- drivers %>% filter(Driver == "MAB+ Txn (Abacus MAB+BranchTxn)") %>% 
  group_by(Driver) %>% summarize(quarter= sum(quarter,na.rm = T)) #
cost<- cost*100000
cost<- as.numeric(cost) # it is stored as df otherwise, and multiplication is not direct
cost

call_df <- MAB_Brtxn_Bdr  # calling the correct driver ( Branch txn only)

df_sel <- call_df[-1]
df_cif <- call_df[1]

df_all <- df_sel * cost
df_all<- cbind(df_cif,df_all)

MAB_Brtxn_Bdr_all <- df_all

(sum(MAB_Brtxn_Bdr_all,na.rm=T)- sum(MAB_Brtxn_Bdr_all$cif_branch_code))- cost # should be 0 

### Final value will be: Abacus value using MAB_Brtxn_Bdr; others using MAB_txn_Bdr
# & excess for Abacus (MAB_txn_Bdr- MAB_Brtxn_Bdr) to be given to Mass
# Final df for Branch Ops and Branch Premises headers
BrOpPrem_Bdr_all <- MAB_txn_Bdr_all_int
BrOpPrem_Bdr_all$Abacus <- MAB_Brtxn_Bdr_all$Abacus
BrOpPrem_Bdr_all$AddToMass <-MAB_txn_Bdr_all_int$Abacus - MAB_Brtxn_Bdr_all$Abacus 
BrOpPrem_Bdr_all$MassNew <- BrOpPrem_Bdr_all$Mass + BrOpPrem_Bdr_all$AddToMass
BrOpPrem_Bdr_all$Mass <- BrOpPrem_Bdr_all$MassNew
BrOpPrem_Bdr_all$MassNew<- NULL; BrOpPrem_Bdr_all$AddToMass<- NULL

(sum(BrOpPrem_Bdr_all,na.rm=T)- sum(BrOpPrem_Bdr_all$cif_branch_code))- cost # should be 0 

rm(call_df)

ob_name <-as.data.frame(ls()); colnames(ob_name)[1]<-"name"
ob_name2 <- ob_name %>% filter(name %like% 'all')

names_df <- ob_name2$name

for (i in names_df) {
  df= get(i)
  print(i)
  print(nrow(df)) # should not be empty df
  print(ncol(df)) # should all have 10 columns
}


# Checks====

Rcode <- read_excel("E:/shubhi ahuja/d/Shubhi/15 Unit Economics/5_JunSep20/inputs/us/Allocated_cost_driver.xlsx",sheet="Rcode")

drivers_chk <- inner_join(drivers,Rcode,by="Driver")

cost_pvt <- drivers_chk %>% dplyr::group_by(RcodeBBB) %>% dplyr::summarize(Total= sum(quarter,na.rm = T)) %>%
  mutate(Total_amt = Total* 100000)

cost_pvt2 <- drivers_chk %>% dplyr::group_by(`Type of costs.x`,Driver,RcodeBBB) %>% dplyr::summarize(Scale_to = sum(quarter,na.rm=T))


# values from pvt should match the ones below

drivers_finance <- drivers %>% select(`Type of costs.x`,Driver)
drivers_finance <- distinct(drivers_finance)

## scale MAB+ Txn (Abacus MAB+BranchTxn) for : Branch Ops Cost, Branch Premises Cost
# Use the below pivot to figure out the various scaling of MAB+ txn
# for everything else, it is straight forward, and then rbind to get Finance Line items

Central_all_BBB<- do.call("rbind",list(BSGBdr_all,CMSBdr_all,cxatmBdr_all,hrBdr_all,ivrBdr_all,
                                       MAB_Brtxn_Bdr_all,MAB_txn_Bdr_all,MF_Bdr_all,PaymentsBdr_all,SR_Bdr_all,
                                       TfxBdr_all,tfxcmsBdr_all,timeaccBdr_all,Trade_Forex_Bdr_all))


Central_all_BBB1<- Central_all_BBB %>% dplyr::group_by(cif_branch_code) %>% dplyr::summarise_all(funs(sum),na.rm=T)
sum(Central_all_BBB1,na.rm=T)- sum(Central_all_BBB1$cif_branch_code) # Overall Check with Allocated file

sum(Central_all_BBB1,na.rm=T)- sum(Central_all_BBB1$cif_branch_code) 

(sum(Central_all_BBB1,na.rm=T)- sum(Central_all_BBB1$cif_branch_code)) - (sum(drivers$quarter,na.rm=T)*100000) #should be 0, everything allocated

cost_pvt
####********** match with values in cost_pvt********
sum(BrOpPrem_Bdr_all,na.rm=T)- sum(BrOpPrem_Bdr_all$cif_branch_code)
sum(FinalBSG_Bdr_all,na.rm=T)- sum(FinalBSG_Bdr_all$cif_branch_code)
sum(CMSBdr_all,na.rm=T)- sum(CMSBdr_all$cif_branch_code)
sum(cxatmBdr_all,na.rm=T)- sum(cxatmBdr_all$cif_branch_code)
sum(hrBdr_all,na.rm=T)- sum(hrBdr_all$cif_branch_code)
sum(ivrBdr_all,na.rm=T)- sum(ivrBdr_all$cif_branch_code)
cost_pvt
sum(MAB_txn_Bdr_all,na.rm=T)- sum(MAB_txn_Bdr_all$cif_branch_code) # chk
sum(MF_Bdr_all,na.rm=T)- sum(MF_Bdr_all$cif_branch_code)
sum(PaymentsBdr_all,na.rm=T)- sum(PaymentsBdr_all$cif_branch_code)
sum(SR_Bdr_all,na.rm=T)- sum(SR_Bdr_all$cif_branch_code)
sum(TfxBdr_all,na.rm=T)- sum(TfxBdr_all$cif_branch_code)
sum(tfxcmsBdr_all,na.rm=T)- sum(tfxcmsBdr_all$cif_branch_code) # Number of trade & forex txns &CMS
sum(timeaccBdr_all,na.rm=T)- sum(timeaccBdr_all$cif_branch_code)
sum(Trade_Forex_Bdr_all,na.rm=T)- sum(Trade_Forex_Bdr_all$cif_branch_code)

setdiff(colnames(CMSBdr_all),colnames(timeaccBdr_all))


# Do one check: Filter on BBB branches again, in the final allocation & check that the sum matches
# i.e., all cost went to BBB only, just a check, coz R can behave strangely at times

#write.csv(Central_all_BBB1,"E:/shubhi ahuja/d/Shubhi/15 Unit Economics/3Jun_Sep2019/inputs/Us/Sep19/cx level files/CentralAllocatedBBBsep.csv",row.names = F)

value_scale_pvt <- drivers %>% dplyr::group_by(`Type of costs.x`,Driver) %>% dplyr::summarize(Scale_to = sum(quarter,na.rm=T))


### Customer level allocation====
masterfile_sel<- masterfile[,c("customer_code","segment","cif_branch_code","cif_branch_name",
                               "avgMAB","total_txns","cxcodeflag")]
masterfile_sel$key<- paste0(masterfile_sel$segment,masterfile_sel$cif_branch_code) 

uniq_branches <- masterfile_sel %>% group_by(cif_branch_code) %>% dplyr::summarize(count=n())

##### making the pivot ######2  
# grouping by key
pivot<- aggregate(masterfile_sel[,c(5,6,7)], by=list(masterfile_sel[,c(8)]), FUN = sum, na.rm=T)
names(pivot)
setnames(pivot, old= "Group.1", new="key")
setnames(pivot, old= "avgMAB", new="Br_seg_MAB")
setnames(pivot, old= "total_txns", new="Br_seg_txns")
setnames(pivot, old= "cxcodeflag", new="Br_seg_cx")
#pivot$segment<- NULL
#pivot$cif_branch_code<- NULL

# Join by 'key' to get the needed table _____________________
use<- left_join(masterfile_sel,pivot,by="key")
colSums(is.na(use))

######### Driver creation cx allocation ############
class(use$Br_seg_MAB);class(use$avgMAB)
str(use)
use$MAB_dr <- use$avgMAB/use$Br_seg_MAB
use$txns_dr<- use$total_txns/use$Br_seg_txns

use_orig <- use # now will remove NaN
use$MAB_dr[is.nan(use$MAB_dr)] <- 0; use$txns_dr[is.nan(use$txns_dr)] <- 0
use$MAB_txns_dr <- (0.5*use$MAB_dr) + (0.5*use$txns_dr)

chk_dr <- use %>% select(cif_branch_code,segment,MAB_dr,txns_dr,MAB_txns_dr)
chk_dr <- chk_dr %>% dplyr::group_by(cif_branch_code,segment) %>% dplyr::summarize(MAB_dr=sum(MAB_dr,na.rm=T),
                                                                                   txns_dr=sum(txns_dr,na.rm=T),
                                                                                   MAB_txns_dr=sum(MAB_txns_dr,na.rm=T))
table(chk_dr$MAB_dr);table(chk_dr$txns_dr);table(chk_dr$MAB_txns_dr)
chk_dr2 <- chk_dr %>% filter(MAB_txns_dr>0 & MAB_txns_dr < 1.0)
chk_dr3 <- chk_dr %>% filter(MAB_txns_dr == 0.5) # doesn't capture all cases we want
chk_dr4 <- chk_dr %>% filter(MAB_txns_dr>0 & MAB_txns_dr < 0.8)
table(chk_dr4$MAB_txns_dr)

use_raw <- use

##  cx allocation Branch ops + Branch Prem ====
input_cost <- BrOpPrem_Bdr_all

# BBB
costs <- input_cost
sum(costs)-sum(costs$cif_branch_code)
names(costs)

cx_branch_pvt <- masterfile %>% dplyr::group_by(cif_branch_code) %>% 
  dplyr::summarize(count_cx = sum(cxcodeflag,na.rm=T))

cx_branch_small <- cx_branch_pvt %>% filter(count_cx < 10) # filtering out branches with < 10 cx
max(cx_branch_small$count_cx)

cost_branch_small <- costs %>% filter(cif_branch_code %in% cx_branch_small$cif_branch_code)
cost_share <- sum(cost_branch_small,na.rm=T)- sum(cost_branch_small$cif_branch_code,na.rm=T)

# branches with >= 10 cx
costs1 <- costs %>% filter(!cif_branch_code %in% cx_branch_small$cif_branch_code)
cost_share_perBranch <- cost_share/nrow(costs1)

(sum(costs)-sum(costs$cif_branch_code)) - ((sum(costs1,na.rm=T)- sum(costs1$cif_branch_code,na.rm=T)) + sum(cost_branch_small)-sum(cost_branch_small$cif_branch_code))

costs12 <- costs1 %>% mutate(TotalBefore = rowSums(costs1[,c("Aspire","Signature","Insignia",
                                                             "Mass","Abacus","Salary","Diplomat",
                                                             "NR","Tasc"),],na.rm = T),
                             cost_share_perBranch = cost_share_perBranch,
                             TotalAfter = TotalBefore + cost_share_perBranch,
                             scaling_ratio = TotalAfter/TotalBefore)

#Total before is total cost value of branches with cx >= 10, before we add costs of branches with <10 cx to them
# Total after is value of cost after we add costs of small branches ( <10 cx) to them
# this is just to get the scaling ratio, branch wise
cost_scale_fn <- function(inVal) {outVal = inVal * costs12$scaling_ratio}

costs13 <- costs12 %>% select(-c(TotalAfter,TotalBefore,cost_share_perBranch))
costs13[,2:(ncol(costs13)-1)] <- lapply(costs13[,2:(ncol(costs13)-1)], cost_scale_fn)

costs13 <- costs13 %>% mutate(AfterScaling = rowSums(costs13[,c("Aspire","Signature","Insignia",
                                                                "Mass","Abacus","Salary","Diplomat",
                                                                "NR","Tasc"),],na.rm = T))

sum(costs13$AfterScaling,na.rm=T)- sum(costs12$TotalAfter) # should be 0, could be a diff if a branch has 0 cost allocated to begin with
sum(costs13$AfterScaling,na.rm=T)- (sum(costs,na.rm = T)- sum(costs$cif_branch_code,na.rm=T)) # should be 0
# could be a diff if a branch has 0 cost allocated to begin with, hence it doesn't scale that
costs14 <- costs13 %>% select(-c(AfterScaling,scaling_ratio))
(sum(costs14,na.rm=T)-sum(costs14$cif_branch_code,na.rm=T))- (sum(costs,na.rm = T)- sum(costs$cif_branch_code,na.rm=T)) # should be 0

costs2 <- melt(costs14, id.vars = "cif_branch_code", variable.name = "segment")
setnames(costs2,old="value",new="total_cost")

costs2$key <- paste0(costs2$segment,costs2$cif_branch_code)
costs2$cif_branch_code<- NULL;costs2$segment<- NULL

sum(costs2$total_cost,na.rm=T)
sum(costs2$total_cost,na.rm=T) - (sum(costs,na.rm = T)- sum(costs$cif_branch_code)) # should be 0

# Joining to add the costs to our use table
use<- use_raw
use<- left_join(use,costs2,by="key")

colSums(is.na(use))
#table(colSums(is.na(use)))
use[is.na(use)]<- 0

use$allocated_cost <- use$MAB_txns_dr * use$total_cost

sum(use$allocated_cost,na.rm=T)
sum(input_cost,na.rm = T)- sum(input_cost$cif_branch_code,na.rm=T)

(sum(input_cost,na.rm = T)- sum(input_cost$cif_branch_code,na.rm=T))-(sum(use$allocated_cost,na.rm=T))

### allocating remaining cost, in equal proportion, to all cx for that segment-branch
rem_pvt<- aggregate(use[,c(16)], by= list(use[,(8)]), FUN = sum, na.rm=T)
names(rem_pvt)
setnames(rem_pvt,old="Group.1",new="key")
setnames(rem_pvt,old="x",new="Allocated_cost_total")
class(rem_pvt$key)
class(rem_pvt$Allocated_cost_total)

use_chk<- left_join(use,rem_pvt,by="key")
use_chk$remaining_cost<- use_chk$total_cost - use_chk$Allocated_cost_total
use_chk <- use_chk %>% filter (abs(remaining_cost)> 1)
#use_chk <- use_chk %>% filter (Br_seg_cx >= 10 & remaining_cost != 0)
max(use_chk$remaining_cost)
max(abs(use_chk$remaining_cost))

use_chk2 <- use_chk %>% filter(!cif_branch_code %in% chk_dr4$cif_branch_code); nrow(use_chk2)# should be 0
# hence all these cases where we weren't able to allocate had driver value = 0.5, hence half the cost got allocated
use2<- use %>% mutate(allocated_cost2 = ifelse(key %in% use_chk$key,allocated_cost*2,allocated_cost))

(sum(input_cost,na.rm = T)- sum(input_cost$cif_branch_code,na.rm=T))-(sum(use2$allocated_cost2,na.rm=T)) # should be ~0

use3 <- use2
use3$allocated_cost <- use3$allocated_cost2
use3$allocated_cost2<- NULL

(sum(input_cost,na.rm = T)- sum(input_cost$cif_branch_code,na.rm=T))-(sum(use3$allocated_cost,na.rm=T)) # should be ~0
# if the diff is small, in few hundreds, can proceed, otherwise, use the snippet from the end 
### Scale as per PnL====
# see value_scale_pvt # to get sense of 2 relevant cost values
#Branch Ops Cost        MAB+ Txn (Abacus MAB+BranchTxn)
#Branch Premises Cost   MAB+ Txn (Abacus MAB+BranchTxn)

# pick value from pnl for the quarter for BBB ( might have to sum MOM value to arrive at value for quarter)

# Branch Premises F131/P131
cr <- 10000000
#qTotal = 4.37172981266798 +5.52945412847628 + 6.15176972848908
pnl <- 24.0440004542995 * cr  # take value from June Pnl, has for the whole quarter

fin <- use3

sum(fin$allocated_cost) # BEFORE
fin$allocated_cost<- ifelse(fin$allocated_cost != 0, fin$allocated_cost*(pnl/sum(fin$allocated_cost)) ,fin$allocated_cost) 
sum(fin$allocated_cost) #After

fin2 <- fin %>% select(customer_code,allocated_cost)
setnames(fin2,old="allocated_cost",new="BranchPremisesCost")

BranchPremBBBcx <- fin2

# Branch Ops F132/P132
pnl <- 24.4388174356506 * cr  # take value from June Pnl, has for the whole quarter

fin <- use3

sum(fin$allocated_cost) # BEFORE
fin$allocated_cost<- ifelse(fin$allocated_cost != 0, fin$allocated_cost*(pnl/sum(fin$allocated_cost)) ,fin$allocated_cost) 
sum(fin$allocated_cost) #After

fin2 <- fin %>% select(customer_code,allocated_cost)
setnames(fin2,old="allocated_cost",new="BranchOpsCost")

BranchOpsBBBcx <- fin2

## cx allocation: Central prem====

input_cost <- MAB_txn_Bdr_all

# BBB
costs <- input_cost
sum(costs)-sum(costs$cif_branch_code)
names(costs)

cx_branch_pvt <- masterfile %>% dplyr::group_by(cif_branch_code) %>% 
  dplyr::summarize(count_cx = sum(cxcodeflag,na.rm=T))

cx_branch_small <- cx_branch_pvt %>% filter(count_cx < 10) # filtering out branches with < 10 cx
max(cx_branch_small$count_cx)

cost_branch_small <- costs %>% filter(cif_branch_code %in% cx_branch_small$cif_branch_code)
cost_share <- sum(cost_branch_small,na.rm=T)- sum(cost_branch_small$cif_branch_code,na.rm=T)

# branches with >= 10 cx
costs1 <- costs %>% filter(!cif_branch_code %in% cx_branch_small$cif_branch_code)
cost_share_perBranch <- cost_share/nrow(costs1)

(sum(costs)-sum(costs$cif_branch_code)) - ((sum(costs1,na.rm=T)- sum(costs1$cif_branch_code,na.rm=T)) + sum(cost_branch_small)-sum(cost_branch_small$cif_branch_code))

costs12 <- costs1 %>% mutate(TotalBefore = rowSums(costs1[,c("Aspire","Signature","Insignia",
                                                             "Mass","Abacus","Salary","Diplomat",
                                                             "NR","Tasc"),],na.rm = T),
                             cost_share_perBranch = cost_share_perBranch,
                             TotalAfter = TotalBefore + cost_share_perBranch,
                             scaling_ratio = TotalAfter/TotalBefore)

#Total before is total cost value of branches with cx >= 10, before we add costs of branches with <10 cx to them
# Total after is value of cost after we add costs of small branches ( <10 cx) to them
# this is just to get the scaling ratio, branch wise
cost_scale_fn <- function(inVal) {outVal = inVal * costs12$scaling_ratio}

costs13 <- costs12 %>% select(-c(TotalAfter,TotalBefore,cost_share_perBranch))
costs13[,2:(ncol(costs13)-1)] <- lapply(costs13[,2:(ncol(costs13)-1)], cost_scale_fn)

costs13 <- costs13 %>% mutate(AfterScaling = rowSums(costs13[,c("Aspire","Signature","Insignia",
                                                                "Mass","Abacus","Salary","Diplomat",
                                                                "NR","Tasc"),],na.rm = T))

sum(costs13$AfterScaling,na.rm=T)- sum(costs12$TotalAfter) # should be 0, the diff could be a multiple of per branch cost
sum(costs13$AfterScaling,na.rm=T)- (sum(costs,na.rm = T)- sum(costs$cif_branch_code,na.rm=T)) # should be 0
# if branch doesn't have cost to begin with, it doesn't get a cost later too
costs14 <- costs13 %>% select(-c(AfterScaling,scaling_ratio))
(sum(costs14,na.rm=T)-sum(costs14$cif_branch_code,na.rm=T))- (sum(costs,na.rm = T)- sum(costs$cif_branch_code,na.rm=T)) # should be 0

costs2 <- melt(costs14, id.vars = "cif_branch_code", variable.name = "segment")
setnames(costs2,old="value",new="total_cost")

costs2$key <- paste0(costs2$segment,costs2$cif_branch_code)
costs2$cif_branch_code<- NULL;costs2$segment<- NULL

sum(costs2$total_cost,na.rm=T)
sum(costs2$total_cost,na.rm=T) - (sum(costs,na.rm = T)- sum(costs$cif_branch_code)) # should be 0
# can be diff bcoz of per branch cost for one branch, minor diff, ~100, if at all
# Joining to add the costs to our use table
use<- use_raw
use<- left_join(use,costs2,by="key")

colSums(is.na(use))
#table(colSums(is.na(use)))
use[is.na(use)]<- 0

use$allocated_cost <- use$MAB_txns_dr * use$total_cost

sum(use$allocated_cost,na.rm=T)
sum(input_cost,na.rm = T)- sum(input_cost$cif_branch_code,na.rm=T)

(sum(input_cost,na.rm = T)- sum(input_cost$cif_branch_code,na.rm=T))-(sum(use$allocated_cost,na.rm=T))

### allocating remaining cost, in equal proportion, to all cx for that segment-branch
rem_pvt<- aggregate(use[,c(16)], by= list(use[,(8)]), FUN = sum, na.rm=T)
names(rem_pvt)
setnames(rem_pvt,old="Group.1",new="key")
setnames(rem_pvt,old="x",new="Allocated_cost_total")
class(rem_pvt$key)
class(rem_pvt$Allocated_cost_total)

use_chk<- left_join(use,rem_pvt,by="key")
use_chk$remaining_cost<- use_chk$total_cost - use_chk$Allocated_cost_total
use_chk <- use_chk %>% filter (abs(remaining_cost)> 1)
#use_chk <- use_chk %>% filter (Br_seg_cx >= 10 & remaining_cost != 0)
max(use_chk$remaining_cost)
max(abs(use_chk$remaining_cost))

use_chk2 <- use_chk %>% filter(!cif_branch_code %in% chk_dr4$cif_branch_code); nrow(use_chk2)# should be 0
# hence all these cases where we weren't able to allocate had driver value = 0.5, hence half the cost got allocated
use2<- use %>% mutate(allocated_cost2 = ifelse(key %in% use_chk$key,allocated_cost*2,allocated_cost))

(sum(input_cost,na.rm = T)- sum(input_cost$cif_branch_code,na.rm=T))-(sum(use2$allocated_cost2,na.rm=T)) # should be ~0

use3 <- use2
use3$allocated_cost <- use3$allocated_cost2
use3$allocated_cost2<- NULL

(sum(input_cost,na.rm = T)- sum(input_cost$cif_branch_code,na.rm=T))-(sum(use3$allocated_cost,na.rm=T)) # should be ~0

# Central Premises from pnl F132/P132
# Central premises in pnl, central offices in allocated cost sheet
pnl <- 4.63048543892154 * cr  # take value from June Pnl, has for the whole quarter

fin <- use3

sum(fin$allocated_cost) # BEFORE
fin$allocated_cost<- ifelse(fin$allocated_cost != 0, fin$allocated_cost*(pnl/sum(fin$allocated_cost)) ,fin$allocated_cost) 
sum(fin$allocated_cost) #After

fin2 <- fin %>% select(customer_code,allocated_cost)
setnames(fin2,old="allocated_cost",new="CentralPremisesCost")

CentralPremBBBcx <- fin2

# Central Functions cost cx====
View(value_scale_pvt)
# use value_scale_pvt/cost_pvt2 to see which driver allocations should be combined & scaling value for mab_txn
# look at value next to----- |Central Function costs  | MAB+ Txn| : 4804.3222

MAB_txn_Bdr_all_adj <- MAB_txn_Bdr_all # value to scale this to will come from the pvt
scale_to <- 3276.89759 * 100000
scale_mab <- (scale_to)/(sum(MAB_txn_Bdr_all_adj,na.rm=T)- sum(MAB_txn_Bdr_all_adj$cif_branch_code,na.rm=T))

sum(MAB_txn_Bdr_all_adj,na.rm=T)- sum(MAB_txn_Bdr_all_adj$cif_branch_code,na.rm=T) # before
MAB_txn_Bdr_all_adj[2:ncol(MAB_txn_Bdr_all_adj)] <- MAB_txn_Bdr_all_adj[2:ncol(MAB_txn_Bdr_all_adj)]*scale_mab 
sum(MAB_txn_Bdr_all_adj,na.rm=T)- sum(MAB_txn_Bdr_all_adj$cif_branch_code,na.rm=T) # after

sum(MAB_txn_Bdr_all_adj,na.rm=T)- sum(MAB_txn_Bdr_all_adj$cif_branch_code,na.rm=T)-(scale_to)# should be 0

input_compile <- rbind(FinalBSG_Bdr_all,hrBdr_all,MAB_txn_Bdr_all_adj)
input_compile[is.na(input_compile)] <- 0
input_compile2 <- input_compile %>% group_by(cif_branch_code) %>% summarize_all(.funs = sum)

sum(input_compile2,na.rm=T)- sum(input_compile2$cif_branch_code) # chk with pvt below

fin_pvt <- drivers %>% dplyr::group_by(`Type of costs.x`) %>% dplyr::summarize(Total= sum(quarter,na.rm = T)*100000)
View(fin_pvt)

input_cost <- input_compile2

# BBB
costs <- input_cost
sum(costs)-sum(costs$cif_branch_code)
names(costs)

cx_branch_pvt <- masterfile %>% dplyr::group_by(cif_branch_code) %>% 
  dplyr::summarize(count_cx = sum(cxcodeflag,na.rm=T))

cx_branch_small <- cx_branch_pvt %>% filter(count_cx < 10) # filtering out branches with < 10 cx
max(cx_branch_small$count_cx)

cost_branch_small <- costs %>% filter(cif_branch_code %in% cx_branch_small$cif_branch_code)
cost_share <- sum(cost_branch_small,na.rm=T)- sum(cost_branch_small$cif_branch_code,na.rm=T)

# branches with >= 10 cx
costs1 <- costs %>% filter(!cif_branch_code %in% cx_branch_small$cif_branch_code)
cost_share_perBranch <- cost_share/nrow(costs1)

(sum(costs)-sum(costs$cif_branch_code)) - ((sum(costs1,na.rm=T)- sum(costs1$cif_branch_code,na.rm=T)) + sum(cost_branch_small)-sum(cost_branch_small$cif_branch_code))

costs12 <- costs1 %>% mutate(TotalBefore = rowSums(costs1[,c("Aspire","Signature","Insignia",
                                                             "Mass","Abacus","Salary","Diplomat",
                                                             "NR","Tasc"),],na.rm = T),
                             cost_share_perBranch = cost_share_perBranch,
                             TotalAfter = TotalBefore + cost_share_perBranch,
                             scaling_ratio = TotalAfter/TotalBefore)

#Total before is total cost value of branches with cx >= 10, before we add costs of branches with <10 cx to them
# Total after is value of cost after we add costs of small branches ( <10 cx) to them
# this is just to get the scaling ratio, branch wise
cost_scale_fn <- function(inVal) {outVal = inVal * costs12$scaling_ratio}

costs13 <- costs12 %>% select(-c(TotalAfter,TotalBefore,cost_share_perBranch))
costs13[,2:(ncol(costs13)-1)] <- lapply(costs13[,2:(ncol(costs13)-1)], cost_scale_fn)

costs13 <- costs13 %>% mutate(AfterScaling = rowSums(costs13[,c("Aspire","Signature","Insignia",
                                                                "Mass","Abacus","Salary","Diplomat",
                                                                "NR","Tasc"),],na.rm = T))

sum(costs13$AfterScaling,na.rm=T)- sum(costs12$TotalAfter) # should be 0
sum(costs13$AfterScaling,na.rm=T)- (sum(costs,na.rm = T)- sum(costs$cif_branch_code,na.rm=T)) # should be 0

costs14 <- costs13 %>% select(-c(AfterScaling,scaling_ratio))
(sum(costs14,na.rm=T)-sum(costs14$cif_branch_code,na.rm=T))- (sum(costs,na.rm = T)- sum(costs$cif_branch_code,na.rm=T)) # should be 0

costs2 <- melt(costs14, id.vars = "cif_branch_code", variable.name = "segment")
setnames(costs2,old="value",new="total_cost")

costs2$key <- paste0(costs2$segment,costs2$cif_branch_code)
costs2$cif_branch_code<- NULL;costs2$segment<- NULL

sum(costs2$total_cost,na.rm=T)
sum(costs2$total_cost,na.rm=T) - (sum(costs,na.rm = T)- sum(costs$cif_branch_code)) # should be 0

# Joining to add the costs to our use table
use<- use_raw
use<- left_join(use,costs2,by="key")

colSums(is.na(use))
#table(colSums(is.na(use)))
use[is.na(use)]<- 0

use$allocated_cost <- use$MAB_txns_dr * use$total_cost

sum(use$allocated_cost,na.rm=T)
sum(input_cost,na.rm = T)- sum(input_cost$cif_branch_code,na.rm=T)

(sum(input_cost,na.rm = T)- sum(input_cost$cif_branch_code,na.rm=T))-(sum(use$allocated_cost,na.rm=T))

### allocating remaining cost, in equal proportion, to all cx for that segment-branch
rem_pvt<- aggregate(use[,c(16)], by= list(use[,(8)]), FUN = sum, na.rm=T)
names(rem_pvt)
setnames(rem_pvt,old="Group.1",new="key")
setnames(rem_pvt,old="x",new="Allocated_cost_total")
class(rem_pvt$key)
class(rem_pvt$Allocated_cost_total)

use_chk<- left_join(use,rem_pvt,by="key")
use_chk$remaining_cost<- use_chk$total_cost - use_chk$Allocated_cost_total
use_chk <- use_chk %>% filter (abs(remaining_cost)> 1)
#use_chk <- use_chk %>% filter (Br_seg_cx >= 10 & remaining_cost != 0)
max(use_chk$remaining_cost)
max(abs(use_chk$remaining_cost))

use_chk2 <- use_chk %>% filter(!cif_branch_code %in% chk_dr4$cif_branch_code); nrow(use_chk2)# should be 0
# hence all these cases where we weren't able to allocate had driver value = 0.5, hence half the cost got allocated
use2<- use %>% mutate(allocated_cost2 = ifelse(key %in% use_chk$key,allocated_cost*2,allocated_cost))

(sum(input_cost,na.rm = T)- sum(input_cost$cif_branch_code,na.rm=T))-(sum(use2$allocated_cost2,na.rm=T)) # should be ~0

use3 <- use2
use3$allocated_cost <- use3$allocated_cost2
use3$allocated_cost2<- NULL

(sum(input_cost,na.rm = T)- sum(input_cost$cif_branch_code,na.rm=T))-(sum(use3$allocated_cost,na.rm=T)) # should be ~0

###adj diff==== 
# since there is a diff still, we have to do some more work


diff_adj <-(sum(input_cost,na.rm = T)- sum(input_cost$cif_branch_code,na.rm=T))-(sum(use3$allocated_cost,na.rm=T)) # should be ~0

costs1 <- costs %>% filter(!cif_branch_code %in% cx_branch_small$cif_branch_code)
#costs1 <- costs1 %>% filter(!cif_branch_code %in% use_chk2$cif_branch_code) # removing the branches with some segments with 0 driver value

cost_share_perBranch2 <- diff_adj/nrow(costs1)

use32 <- use3 %>% filter (!key %in% use_chk2$key) # removing cases with 0 driver value

use3_pvt <- use3 %>% dplyr::group_by(cif_branch_code,segment) %>% dplyr::summarize(cost = sum(allocated_cost,na.rm=T))
use3_pvt2 <- dcast(use3_pvt,cif_branch_code~segment,value.var = "cost")
use3_pvt2[is.na(use3_pvt2)]<- 0

use3_pvt2 <- use3_pvt2 %>% filter(cif_branch_code %in% costs1$cif_branch_code)

(sum(use3_pvt2)- sum(use3_pvt2$cif_branch_code))- sum(use3$allocated_cost) # should be 0

costs12 <- use3_pvt2 %>% mutate(TotalBefore = rowSums(use3_pvt2[,c("Aspire","Signature","Insignia",
                                                                   "Mass","Abacus","Salary","Diplomat",
                                                                   "NR","Tasc"),],na.rm = T),
                                cost_share_perBranch2 = cost_share_perBranch2,
                                TotalAfter = TotalBefore + cost_share_perBranch2,
                                scaling_ratio = TotalAfter/TotalBefore)

#Total before is total cost value of branches with cx >= 10, before we add costs of branches with <10 cx to them
# Total after is value of cost after we add costs of small branches ( <10 cx) to them
# this is just to get the scaling ratio, branch wise
cost_scale_fn <- function(inVal) {outVal = inVal * costs12$scaling_ratio}

costs13 <- costs12 %>% select(-c(TotalAfter,TotalBefore,cost_share_perBranch2))
costs13[,2:(ncol(costs13)-1)] <- lapply(costs13[,2:(ncol(costs13)-1)], cost_scale_fn)

costs13 <- costs13 %>% mutate(AfterScaling = rowSums(costs13[,c("Aspire","Signature","Insignia",
                                                                "Mass","Abacus","Salary","Diplomat",
                                                                "NR","Tasc"),],na.rm = T))

sum(costs13$AfterScaling,na.rm=T)- sum(costs12$TotalAfter) # should be 0
sum(costs13$AfterScaling,na.rm=T)- (sum(costs,na.rm = T)- sum(costs$cif_branch_code,na.rm=T)) # should be 0

costs14 <- costs13 %>% select(-c(AfterScaling,scaling_ratio))
(sum(costs14,na.rm=T)-sum(costs14$cif_branch_code,na.rm=T))- (sum(costs,na.rm = T)- sum(costs$cif_branch_code,na.rm=T)) # should be 0

costs2 <- melt(costs14, id.vars = "cif_branch_code", variable.name = "segment")
setnames(costs2,old="value",new="total_cost")

costs2$key <- paste0(costs2$segment,costs2$cif_branch_code)
costs2$cif_branch_code<- NULL;costs2$segment<- NULL

sum(costs2$total_cost,na.rm=T)
sum(costs2$total_cost,na.rm=T) - (sum(costs,na.rm = T)- sum(costs$cif_branch_code)) # should be 0

# Joining to add the costs to our use table
use<- use_raw
use<- left_join(use,costs2,by="key")

colSums(is.na(use))
#table(colSums(is.na(use)))
use[is.na(use)]<- 0

use$allocated_cost <- use$MAB_txns_dr * use$total_cost

sum(use$allocated_cost,na.rm=T)
sum(input_cost,na.rm = T)- sum(input_cost$cif_branch_code,na.rm=T)

(sum(input_cost,na.rm = T)- sum(input_cost$cif_branch_code,na.rm=T))-(sum(use$allocated_cost,na.rm=T))

### allocating remaining cost, in equal proportion, to all cx for that segment-branch
rem_pvt<- aggregate(use[,c(16)], by= list(use[,(8)]), FUN = sum, na.rm=T)
names(rem_pvt)
setnames(rem_pvt,old="Group.1",new="key")
setnames(rem_pvt,old="x",new="Allocated_cost_total")
class(rem_pvt$key)
class(rem_pvt$Allocated_cost_total)

use_chk<- left_join(use,rem_pvt,by="key")
use_chk$remaining_cost<- use_chk$total_cost - use_chk$Allocated_cost_total
use_chk <- use_chk %>% filter (abs(remaining_cost)> 1)
#use_chk <- use_chk %>% filter (Br_seg_cx >= 10 & remaining_cost != 0)
max(use_chk$remaining_cost)
max(abs(use_chk$remaining_cost))

use_chk2 <- use_chk %>% filter(!cif_branch_code %in% chk_dr4$cif_branch_code); nrow(use_chk2)# should be 0
# hence all these cases where we weren't able to allocate had driver value = 0.5, hence half the cost got allocated
use2<- use %>% mutate(allocated_cost2 = ifelse(key %in% use_chk$key,allocated_cost*2,allocated_cost))

(sum(input_cost,na.rm = T)- sum(input_cost$cif_branch_code,na.rm=T))-(sum(use2$allocated_cost2,na.rm=T)) # should be ~0

use3 <- use2
use3$allocated_cost <- use3$allocated_cost2
use3$allocated_cost2<- NULL

(sum(input_cost,na.rm = T)- sum(input_cost$cif_branch_code,na.rm=T))-(sum(use3$allocated_cost,na.rm=T)) # should be ~0

### pnl====
# CentralFunctionsCost from pnl F134/P134
# CentralFunctionsCost in allocated cost sheet
pnl <- 50.5508533317576 * cr  # take value from June Pnl, has for the whole quarter

fin <- use3

sum(fin$allocated_cost) # BEFORE
fin$allocated_cost<- ifelse(fin$allocated_cost != 0, fin$allocated_cost*(pnl/sum(fin$allocated_cost)) ,fin$allocated_cost) 
sum(fin$allocated_cost) #After

fin2 <- fin %>% select(customer_code,allocated_cost)
setnames(fin2,old="allocated_cost",new="CentralFunctionsCost")

CentralFuncBBBcx <- fin2









# Directly attributable cost cx====
View(value_scale_pvt)
View(cost_pvt2)
# use value_scale_pvt/cost_pvt2 to see which driver allocations should be combined & scaling value for mab_txn
# look at value next to----- |Directly attributable  | MAB+ Txn| 

MAB_txn_Bdr_all_adj <- MAB_txn_Bdr_all # value to scale this to will come from the pvt
scale_to <- 73.26002 * 100000
scale_mab <- (scale_to)/(sum(MAB_txn_Bdr_all_adj,na.rm=T)- sum(MAB_txn_Bdr_all_adj$cif_branch_code,na.rm=T))

sum(MAB_txn_Bdr_all_adj,na.rm=T)- sum(MAB_txn_Bdr_all_adj$cif_branch_code,na.rm=T) # before
MAB_txn_Bdr_all_adj[2:ncol(MAB_txn_Bdr_all_adj)] <- MAB_txn_Bdr_all_adj[2:ncol(MAB_txn_Bdr_all_adj)]*scale_mab 
sum(MAB_txn_Bdr_all_adj,na.rm=T)- sum(MAB_txn_Bdr_all_adj$cif_branch_code,na.rm=T) # after

sum(MAB_txn_Bdr_all_adj,na.rm=T)- sum(MAB_txn_Bdr_all_adj$cif_branch_code,na.rm=T)-(scale_to)# should be 0

# compiling drivers that make up directly attributable ( cost pvt 2) 
# instead of MAB_txn_Bdr_all, we'll use the adjusted df above MAB_txn_Bdr_all_adj, with correctly scaled values

input_compile <- rbind(cxatmBdr_all,CMSBdr_all,ivrBdr_all,MAB_txn_Bdr_all_adj,MF_Bdr_all,timeaccBdr_all,
                       Trade_Forex_Bdr_all,TfxBdr_all,tfxcmsBdr_all,PaymentsBdr_all,SR_Bdr_all)

input_compile[is.na(input_compile)] <- 0
input_compile2 <- input_compile %>% group_by(cif_branch_code) %>% summarize_all(.funs = sum)

sum(input_compile2,na.rm=T)- sum(input_compile2$cif_branch_code) # chk with pvt below

View(fin_pvt) # compare value with Directly attributable in thr pvt

input_cost <- input_compile2

# BBB
costs <- input_cost
sum(costs)-sum(costs$cif_branch_code)
names(costs)

cx_branch_pvt <- masterfile %>% dplyr::group_by(cif_branch_code) %>% 
  dplyr::summarize(count_cx = sum(cxcodeflag,na.rm=T))

cx_branch_small <- cx_branch_pvt %>% filter(count_cx < 10) # filtering out branches with < 10 cx
max(cx_branch_small$count_cx)

cost_branch_small <- costs %>% filter(cif_branch_code %in% cx_branch_small$cif_branch_code)
cost_share <- sum(cost_branch_small,na.rm=T)- sum(cost_branch_small$cif_branch_code,na.rm=T)

# branches with >= 10 cx
costs1 <- costs %>% filter(!cif_branch_code %in% cx_branch_small$cif_branch_code)
cost_share_perBranch <- cost_share/nrow(costs1)

(sum(costs)-sum(costs$cif_branch_code)) - ((sum(costs1,na.rm=T)- sum(costs1$cif_branch_code,na.rm=T)) + sum(cost_branch_small)-sum(cost_branch_small$cif_branch_code))

costs12 <- costs1 %>% mutate(TotalBefore = rowSums(costs1[,c("Aspire","Signature","Insignia",
                                                             "Mass","Abacus","Salary","Diplomat",
                                                             "NR","Tasc"),],na.rm = T),
                             cost_share_perBranch = cost_share_perBranch,
                             TotalAfter = TotalBefore + cost_share_perBranch,
                             scaling_ratio = TotalAfter/TotalBefore)

#Total before is total cost value of branches with cx >= 10, before we add costs of branches with <10 cx to them
# Total after is value of cost after we add costs of small branches ( <10 cx) to them
# this is just to get the scaling ratio, branch wise
cost_scale_fn <- function(inVal) {outVal = inVal * costs12$scaling_ratio}

costs13 <- costs12 %>% select(-c(TotalAfter,TotalBefore,cost_share_perBranch))
costs13[,2:(ncol(costs13)-1)] <- lapply(costs13[,2:(ncol(costs13)-1)], cost_scale_fn)

costs13 <- costs13 %>% mutate(AfterScaling = rowSums(costs13[,c("Aspire","Signature","Insignia",
                                                                "Mass","Abacus","Salary","Diplomat",
                                                                "NR","Tasc"),],na.rm = T))

sum(costs13$AfterScaling,na.rm=T)- sum(costs12$TotalAfter) # should be 0
sum(costs13$AfterScaling,na.rm=T)- (sum(costs,na.rm = T)- sum(costs$cif_branch_code,na.rm=T)) # should be 0

costs14 <- costs13 %>% select(-c(AfterScaling,scaling_ratio))
(sum(costs14,na.rm=T)-sum(costs14$cif_branch_code,na.rm=T))- (sum(costs,na.rm = T)- sum(costs$cif_branch_code,na.rm=T)) # should be 0

costs2 <- melt(costs14, id.vars = "cif_branch_code", variable.name = "segment")
setnames(costs2,old="value",new="total_cost")

costs2$key <- paste0(costs2$segment,costs2$cif_branch_code)
costs2$cif_branch_code<- NULL;costs2$segment<- NULL

sum(costs2$total_cost,na.rm=T)
sum(costs2$total_cost,na.rm=T) - (sum(costs,na.rm = T)- sum(costs$cif_branch_code)) # should be 0

# Joining to add the costs to our use table
use<- use_raw
use<- left_join(use,costs2,by="key")

colSums(is.na(use))
#table(colSums(is.na(use)))
use[is.na(use)]<- 0

use$allocated_cost <- use$MAB_txns_dr * use$total_cost

sum(use$allocated_cost,na.rm=T)
sum(input_cost,na.rm = T)- sum(input_cost$cif_branch_code,na.rm=T)

(sum(input_cost,na.rm = T)- sum(input_cost$cif_branch_code,na.rm=T))-(sum(use$allocated_cost,na.rm=T))

### allocating remaining cost, in equal proportion, to all cx for that segment-branch
rem_pvt<- aggregate(use[,c(16)], by= list(use[,(8)]), FUN = sum, na.rm=T)
names(rem_pvt)
setnames(rem_pvt,old="Group.1",new="key")
setnames(rem_pvt,old="x",new="Allocated_cost_total")
class(rem_pvt$key)
class(rem_pvt$Allocated_cost_total)

use_chk<- left_join(use,rem_pvt,by="key")
use_chk$remaining_cost<- use_chk$total_cost - use_chk$Allocated_cost_total
use_chk <- use_chk %>% filter (abs(remaining_cost)> 1)
#use_chk <- use_chk %>% filter (Br_seg_cx >= 10 & remaining_cost != 0)
max(use_chk$remaining_cost)
max(abs(use_chk$remaining_cost))

use_chk2 <- use_chk %>% filter(!cif_branch_code %in% chk_dr4$cif_branch_code); nrow(use_chk2)# should be 0
# hence all these cases where we weren't able to allocate had driver value = 0.5, hence half the cost got allocated
use2<- use %>% mutate(allocated_cost2 = ifelse(key %in% use_chk$key,allocated_cost*2,allocated_cost))

(sum(input_cost,na.rm = T)- sum(input_cost$cif_branch_code,na.rm=T))-(sum(use2$allocated_cost2,na.rm=T)) # should be ~0

use3 <- use2
use3$allocated_cost <- use3$allocated_cost2
use3$allocated_cost2<- NULL

(sum(input_cost,na.rm = T)- sum(input_cost$cif_branch_code,na.rm=T))-(sum(use3$allocated_cost,na.rm=T)) # should be ~0


## pnl====
# Directly Identifiable Costs from pnl F130/P130
# Directly Identifiable Costsin pnl, Directly attributable in allocated cost sheet
pnl <- 24.0809350635647 * cr  # take value from June Pnl, has for the whole quarter

fin <- use3

sum(fin$allocated_cost) # BEFORE
fin$allocated_cost<- ifelse(fin$allocated_cost != 0, fin$allocated_cost*(pnl/sum(fin$allocated_cost)) ,fin$allocated_cost) 
sum(fin$allocated_cost) #After

fin2 <- fin %>% select(customer_code,allocated_cost)
setnames(fin2,old="allocated_cost",new="DirectlyIdentifiableCosts")

DirectIdenBBBcx <- fin2


### writing output Bbb+ rbu====
#BranchOpscx <- rbind(BranchOpsBBBcx,BranchOpsRBUcx) # rbind BBB & RBU files for the 5 fin headers ( search for cx in df)
#BranchPremcx <- rbind(BranchPremBBBcx,BranchPremRBUcx)

# lwft join all 5 costs in one df ( BBB, RBU) and then write that one file

#finalCostcx <- left_join(masterfile,BranchOpscx,by="customer_code")
#finalCostcx <- left_join(finalCostcx,BranchPremcx,by="customer_code")

finalCostcx <- left_join(masterfile,BranchOpsBBBcx,by="customer_code")
finalCostcx <- left_join(finalCostcx,BranchPremBBBcx,by="customer_code")
finalCostcx <- left_join(finalCostcx,CentralFuncBBBcx,by="customer_code")
finalCostcx <- left_join(finalCostcx,CentralPremBBBcx,by="customer_code")
finalCostcx <- left_join(finalCostcx,DirectIdenBBBcx,by="customer_code")

final_chk <- finalCostcx %>% select(BranchOpsCost,BranchPremisesCost,CentralPremisesCost,
                                    CentralFunctionsCost,DirectlyIdentifiableCosts)
colSums(final_chk,na.rm=T)/cr

fin <- finalCostcx %>% select(customer_code,BranchOpsCost,BranchPremisesCost,CentralPremisesCost,
                              CentralFunctionsCost,DirectlyIdentifiableCosts)



setwd("E:\\shubhi ahuja\\d\\Shubhi\\15 Unit Economics\\6_Dec20\\outputs\\2cost")#
str(fin)
write.csv(fin,"Allocated_costsQ3FY21.csv",row.names=F)

#write.csv(finalCostcx,"June20Rev_centralcost.csv",row.names = F)
# check final sum of finalCostcx, should tally with BBB + RBU cost for the quarter

#write.csv(finalCostcx,"AllocatedcostcxQ1.csv",row.names = F)
## branch segment file for some cost types
write.csv(FinalBSG_Bdr_all,"Dec20BSG_centralcost.csv",row.names = F)
write.csv(hrBdr_all,"Dec20HR_centralcost.csv",row.names = F)
write.csv(timeaccBdr_all,"Dec20CentralOps_centralcost.csv",row.names = F)
write.csv(Trade_Forex_Bdr_all,"Dec20WholesaleClient_centralcost.csv",row.names = F)
write.csv(SR_Bdr_all,"Dec20ClientServices_centralcost.csv",row.names = F)


## HR mgr====
library(dplyr)
library(readxl)
library(data.table)
library(lubridate)
options(scipen=999)

# Analysis to be done at business unit level.#A business unit will encompass different job roles,
# we will be making comparisons basis only attrition as the criterion. 
# All active Managers with team size (no of reportees) > Avg team size for the business unit will be considered.
# Managers for whom the attrition > avg attrition for the business unit, will be flagged.
# Attrition after 1-April-2019 (>=will be taken as attrition=1/True. )
# Total pool of employees for analysis would be of live employees + employees with DOR afetr cutoff date.

input_raw <- read_excel("E:/shubhi ahuja/d/Shubhi/4 HR project/HR Attrition/Predictions/input/Data - Nov/Attrition - Nov.xlsx")
str(input_raw)

table(input_raw$`Business Unit`)
class(input_raw$DOR)

cutoffDate <- as.Date('01-04-2019',format='%d-%m-%Y')
#fixed_day<- strftime(today(), format="%Y-%m-01") # firts date of current month

max(input_raw$DOR,na.rm=T)

i1 <- input_raw %>% mutate(DOR_keep = ifelse(DOR >= cutoffDate,1,0))
table(i1$DOR_keep)
#i1$DOR_keep <- ifelse(is.na(i1$DOR_keep),0,i1$DOR_keep); table(i1$DOR_keep)                   
# Keeping Live employees/ employees with DOR > 1 April2019
i2 <- i1 %>% filter(DOR_keep==1 | is.na(DOR))
i2$DOR_keep <- ifelse(i2$DOR_keep==0,"Live",i2$DOR_keep); table(i2$DOR_keep) 
i2$Exited <- ifelse(is.na(i2$DOR),0,1)
table(i2$Exited)

chk <- i2 %>% group_by(DOR_keep) %>% summarize(minDOR = min(DOR),
                                               maxDOR= max(DOR))
chk

# Pool to analyze on : DOR after cutoff + live (no DOR) emp
mgr_bu <- input_raw %>% select(`Emp Id`,`Business Unit`)

# average team size 
pvt_manager <- i2 %>% group_by(`Mgr Id`) %>% summarize(reportees = n(),Exited_mgr= sum(Exited),
                                                       AttritionRate_Mgr = Exited_mgr/reportees)
# mapping BU to managers
pvt_manager2 <- left_join(pvt_manager,mgr_bu,by=c("Mgr Id"="Emp Id"))


# average attrition under manager, basis business unit
BU_attr <- i2 %>% group_by(`Business Unit`) %>% summarize(Total_emp_BU = n(),
                                                          Exited_BU= sum(Exited),
                                                          AttritionRate_BU = Exited_BU/Total_emp_BU)

BU_attr2 <- pvt_manager2 %>% group_by(`Business Unit`) %>% summarize(AvgTeamSize_BU= mean(reportees,na.rm = T),
                                                                     AvgAttrition_mgr_BU = mean(AttritionRate_Mgr,na.rm=T))

# Filterting to get details of only managers from Masterfile
mgr <- i2 %>% filter (`Emp Id` %in% pvt_manager$`Mgr Id`)
chk_mis <- pvt_manager %>% filter (!`Mgr Id` %in% mgr$`Emp Id`)
chk_mis2 <- left_join(chk_mis,input_raw,by=c("Mgr Id"="Emp Id"))
table(chk_mis2$`Employee Status`) 
chk_mis3 <- chk_mis2 %>% filter (`Employee Status` != "Inactive" | is.na(`Employee Status`))

# Analysis on Active Managers only***********************
mgr2 <- mgr %>% filter(`Employee Status` == "Active")
names(mgr2)

## mapping manager details
mgr3 <- left_join(mgr2,pvt_manager,by=c("Emp Id"="Mgr Id"))

## Mapping BU details next to managers
mgr4 <- left_join(mgr3,BU_attr,by="Business Unit")

# Mapping avg team size
mgr5 <- left_join(mgr4,BU_attr2,by="Business Unit"); nrow(mgr5)

file_base <- mgr5

## Filter 

# All active Managers with team size (no of reportees) > Avg team size for the business unit will be considered.
nrow(file_base)
f1 <- file_base %>% filter(reportees>= AvgTeamSize_BU)
nrow(f1)

# Managers for whom the attrition > avg attrition for the business unit, will be flagged.
f2 <- f1 %>% mutate(HighAttrition_mgr = ifelse(AttritionRate_Mgr > AttritionRate_BU,1,0))
table(f2$HighAttrition_mgr)

f3 <- f2 %>% filter(`ManCom Flag`==0)

f4 <- f3 %>% arrange(`Business Unit`,-AttritionRate_Mgr)

calc <- f4 %>% filter(HighAttrition_mgr==1) %>%
  group_by(`Business Unit`) %>% summarise(p50_Atrr_Mgr = quantile(AttritionRate_Mgr,probs = .5),
                                          p75_Atrr_Mgr = quantile(AttritionRate_Mgr,probs = .75))

f5 <- left_join(f4,calc,by="Business Unit")
f5<- f5 %>% mutate(Bucket= ifelse(HighAttrition_mgr==1 & AttritionRate_Mgr > p75_Atrr_Mgr,"High",
                                  ifelse(HighAttrition_mgr==1 & AttritionRate_Mgr > p50_Atrr_Mgr,"Medium",
                                         ifelse(HighAttrition_mgr==0,NA,"Low"))))

f5$AvgAttrition_mgr_BU <- NULL
f5$`Employee Number` <- NULL

att_model <- read_excel("E:/shubhi ahuja/d/Shubhi/4 HR project/HR Attrition/Predictions/output/EmpPropensity_Oct20_v2.xlsx")
att_model2 <- att_model %>% select(`Emp Id`,Propensity,`Mgr Id`)
att_model2 <- att_model2 %>% mutate(FlagHighPropensity = ifelse(Propensity>=0.75,1,0),
                                    Propensity_HighBkt = ifelse(Propensity>=0.75,Propensity,NA))

att_model_mgrPvt = att_model2 %>% group_by(`Mgr Id`) %>% summarize(Count_HighAttrProp = sum(FlagHighPropensity),
                                                                   AvgPropensity_HighAttrProp = mean(Propensity_HighBkt,na.rm = T))


f6<- left_join(f5,att_model_mgrPvt,by="Mgr Id")

output <- f6

setwd("E:\\shubhi ahuja\\d\\Shubhi\\4 HR project\\HR Manager\\outputs\\chk")

library(writexl)
#write_xlsx(file_base,"filebase2.xlsx")
#write_xlsx(f2,"f2_v2.xlsx")
#write_xlsx(output,"output_V2.xlsx")


### Adding details====
# Priority to be given to High Attrition Manager- Map additional details:
#   Count of employees with a High rating (1,2,3) under the manager.
# Map reportees' info from exit data.
# Rating of Manager to be mapped as well. 

rating_lat <- read_excel("E:/shubhi ahuja/d/Shubhi/4 HR project/HR Attrition/Predictions/CommonInputs/Ratings 2020.xlsx")
str(rating_lat)
rating_lat$`Emp. Code` <- as.character(rating_lat$`Emp. Code`)
# Map rating value
rating_conv <- read_excel("E:/shubhi ahuja/d/Shubhi/4 HR project/HR Attrition/Predictions/CommonInputs/Rating_Grade_Convention.xlsx",sheet="Rating_convention")
rating_lat$`Rating 2020` <- tolower(rating_lat$`Rating 2020`)
rating_conv$Rating <- tolower(rating_conv$Rating)

rating_lat2 <- left_join(rating_lat,rating_conv,by=c("Rating 2020"="Rating"))
colSums(is.na(rating_lat2)) # rating point should not have nulls
setnames(rating_lat2,old="Rating_point",new="RatingPt2020")

mapRating <- left_join(f6,rating_lat2,by=c("Emp Id"="Emp. Code"))
mapRating2 <- mapRating %>% select(`Emp Id`,`Rating 2020`)

f7 <- left_join(f6,mapRating2,by="Emp Id")

# 2019
# Rating 2019====
setwd("E:\\shubhi ahuja\\d\\Shubhi\\4 HR project\\HR Attrition\\Predictions\\CommonInputs")
ctc<- read_excel("Copy of Comp Data_30 - 9 -2019.xlsx")
setnames(ctc,old="Encoded Emp. Code",new="Emp Id"); setnames(ctc,old="% difference\r\n(CTC - Mean)",new="CTC_mean_per_diff")
setnames(ctc,old="% Hike 2018-19",new="SalaryHike_2019"); setnames(ctc,old="Rating 2018-19",new="Rating2019")

ctc$`Emp Id`<- as.character(ctc$`Emp Id`)
ctc2<- ctc %>% select(`Emp Id`,CTC_mean_per_diff)

rating2019 <- ctc %>% select(`Emp Id`,Rating2019)
rating2019$Rating2019 <- tolower(rating2019$Rating2019)
rating2019 <- left_join(rating2019,rating_conv,by=c("Rating2019"="Rating"))
colSums(is.na(rating2019)) # rating point should not have nulls
setnames(rating2019,old="Rating_point",new="RatingPt2019")

mapRating2 <- rating2019 %>% select(`Emp Id`,Rating2019)

f7 <- left_join(f7,mapRating2,by="Emp Id")


### Mapping emp under these managers from the pool (live + exit after threshold)
rep <- f7 %>% select(`Emp Id`)
rep <- inner_join(i2,rep,by=c("Mgr Id"="Emp Id"))
max(rep$DOR,na.rm=T);min(rep$DOR,na.rm=T)
chkdupl <- rep[duplicated(rep$`Emp Id`),]; nrow(chkdupl)
### Mapping Rating of emp under these managers

rep2 <- rep %>% select(`Mgr Id`,`Emp Id`,Exited)

# 2020
mapRating <- left_join(rep2,rating_lat2,by=c("Emp Id"="Emp. Code"))
mapRating2 <- mapRating %>% select(`Emp Id`,RatingPt2020)
mapRating3 <- mapRating2 %>% filter(RatingPt2020 >= 4) # high rated emp
rep3 <- left_join(rep2,mapRating3,by="Emp Id")

# 2019
mapRating2 <- rating2019 %>% select(`Emp Id`,RatingPt2019)
mapRating3 <- mapRating2 %>% filter(RatingPt2019 >= 4) # high rated emp
rep4 <- left_join(rep3,mapRating3,by="Emp Id")

str(rep4)
rep4 <- as.data.frame(rep4)

#highRat <- rep4 %>% dplyr::group_by(`Mgr Id`) %>% summarize(HighRatedEmp2019 = sum(RatingPt2019,na.rm=T),
#                                                            HighRatedEmp2020 = sum(RatingPt2020,na.rm=T))

# All emp rating count
highRat <- rep4 %>% select(-c(`Emp Id`,Exited))
highRat <- highRat %>% group_by(`Mgr Id`) %>% summarise_each(funs(sum(!is.na(.))))
setnames(highRat,old="RatingPt2019",new="HighRatedEmp2019_Total")
setnames(highRat,old="RatingPt2020",new="HighRatedEmp2020_Total")
highRatAll <- highRat

# Live emp rating
highRat <- rep4 %>% select(-c(`Emp Id`))
highRat <- highRat %>%filter(Exited==0) %>%select(-c(Exited)) %>% group_by(`Mgr Id`) %>% summarise_each(funs(sum(!is.na(.))))
setnames(highRat,old="RatingPt2019",new="HighRatedEmp2019_Live")
setnames(highRat,old="RatingPt2020",new="HighRatedEmp2020_Live")
highRatLive <- highRat

# Exited emp rating
highRat <- rep4 %>% select(-c(`Emp Id`))
highRat <- highRat %>%filter(Exited==1) %>%select(-c(Exited)) %>%group_by(`Mgr Id`) %>% summarise_each(funs(sum(!is.na(.))))
setnames(highRat,old="RatingPt2019",new="HighRatedEmp2019_Exited")
setnames(highRat,old="RatingPt2020",new="HighRatedEmp2020_Exited")
highRatExited <- highRat

f8 <- left_join(f7,highRatAll,by="Mgr Id")
f8 <- left_join(f8,highRatLive,by="Mgr Id")
f8 <- left_join(f8,highRatExited,by="Mgr Id")

### Exit data====
exitsurvey <- read_excel("E:/shubhi ahuja/d/Shubhi/4 HR project/HR Manager/RBL BankResignation Survey 2019.xlsx")
exitsurvey2 <- exitsurvey %>% select(`Emp Id`,`Please mention the one main reason which caused you to start looking for another job, state Primary reason out of the below category :`)
colnames(exitsurvey2)[2] <- "Reason"

exitsurvey3 <- left_join(rep2,exitsurvey2,by="Emp Id")
colSums(is.na(exitsurvey3))

exitsurvey3$flag <- 1
#exitsurvey4 <- reshape(exitsurvey3,idvar="Mgr Id",timevar = "Reason",values="flag",direction="wide")
library(reshape2)
exitsurvey4 <- dcast(exitsurvey3,`Mgr Id`~Reason, value.var = "flag")
setnames(exitsurvey4,old="NA",new="CountEmpSurveyNotTaken")

f9<- left_join(f8,exitsurvey4,by=c("Emp Id"="Mgr Id"))

setwd("E:\\shubhi ahuja\\d\\Shubhi\\4 HR project\\HR Manager\\outputs")

f91 <- f9 %>% mutate(Bucket_Final = ifelse(HighAttrition_mgr==1 & Bucket %in% c('High','Medium') & Exited_mgr <= 2,"Low",Bucket),
                     Bucket_updated = ifelse(HighAttrition_mgr==1 & Bucket %in% c('High','Medium') & Exited_mgr <= 2,1,0))

write_xlsx(f91,"ManagerAnalysis_v2.xlsx")
